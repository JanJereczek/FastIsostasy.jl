<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · FastIsostasy.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FastIsostasy.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FastIsostasy.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">FastIsostasy.jl</a></li><li><a class="tocitem" href="../introGIA/">A quick introduction to GIA</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Multi-layer-Earth"><span>Multi-layer Earth</span></a></li><li><a class="tocitem" href="#Simple-load-and-geometry"><span>Simple load and geometry</span></a></li><li><a class="tocitem" href="#Make-your-own-time-loop"><span>Make your own time loop</span></a></li><li><a class="tocitem" href="#Antarctic-deglaciation"><span>Antarctic deglaciation</span></a></li><li><a class="tocitem" href="#Inversion-of-viscosity-field"><span>Inversion of viscosity field</span></a></li></ul></li><li><a class="tocitem" href="../APIref/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JanJereczek/FastIsostasy.jl/blob/main/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Multi-layer-Earth"><a class="docs-heading-anchor" href="#Multi-layer-Earth">Multi-layer Earth</a><a id="Multi-layer-Earth-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-layer-Earth" title="Permalink"></a></h2><p>FastIsostasy relies on a (polar) stereographic projection that allows to treat the radially-layered, onion-like structure of the solid Earth as a superposition of horizontal layers. Furthermore, FastIsostasy reduces this 3D problem into a 2D problem by collapsing the depth dimension, mainly through the computation of an effective viscosity field that accounts for the superposition of layers with different viscosities. The user is required to provide the 3D information, which will then be used under the hood to compute the effective viscosity. This tutorial shows such an example.</p><p>We want to render a situation similar to the one depicted below:</p><p><img src="../assets/sketch_nlayer_model.png" alt="Schematic representation of the three-layer set-up."/></p><p>Initializing a <a href="../APIref/#FastIsostasy.LateralVariability"><code>LateralVariability</code></a> with parameters corresponding to this situation automatically computes the conversion from a 3D to a 2D problem. This can be simply executed by running:</p><pre><code class="language-julia hljs">using FastIsostasy

W = 3000e3      # (m) half-width of the domain Wx = Wy
n = 6           # implies an Nx x Ny grid with Nx = Ny = 2^n = 64.
Omega = ComputationDomain(W, n)
c = PhysicalConstants(rho_litho = 0.0)

lv = [1e19, 1e21]       # (Pa s)
lb = [88e3, 400e3]      # (m)
p = LateralVariability(Omega, layer_viscosities = lv, layer_boundaries = lb)
extrema(p.effective_viscosity)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>As expected, the effective viscosity is a homogeneous field. It corresponds to a nonlinear mean of the layered values provided by the user. Note that we have set <span>$ŗho_\mathrm{litho} = 0$</span> to prevent the lithosphere from contributing to the hydrostatic, upward force. This is made to comply with the later computed analytical solution, which assumes a purely elastic lithosphere. In reality, this is however arguably wrong and the default choice <code>c = PhysicalConstants()</code> therefore uses <span>$ŗho_\mathrm{litho} = 2600 \, \mathrm{kg \, m^{-3}}$</span>.</p><p>The next section shows how to use the now obtained <code>p::LateralVariability</code> for actual GIA computation.</p><h2 id="Simple-load-and-geometry"><a class="docs-heading-anchor" href="#Simple-load-and-geometry">Simple load and geometry</a><a id="Simple-load-and-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-load-and-geometry" title="Permalink"></a></h2><p>We now apply a constant load, here a cylinder of ice with radius <span>$R = 1000 \, \mathrm{km}$</span> and thickness <span>$H = 1 \, \mathrm{km}$</span>, over <code>Omega::ComputationDomain</code> introduced in <a href="#Multi-layer-Earth">Multi-layer Earth</a>. To formulate the problem conviniently, we use <a href="../APIref/#FastIsostasy.FastIsoProblem"><code>FastIsoProblem</code></a>, a struct containing the variables and options that are necessary to perform the integration over time. We can then simply apply <code>solve!(fip::FastIsoProblem)</code> to perform the integration of the ODE. Under the hood, the ODE is obtained from the PDE by applying a Fourier collocation scheme contained in <a href="../APIref/#FastIsostasy.dudt_isostasy!"><code>dudt_isostasy!</code></a>. The integration is performed according to <code>FastIsoProblem.diffeq::NamedTuple</code>, which contains the algorithm and optionally tolerances, maximum iteration number... etc.</p><pre><code class="language-julia hljs">using CairoMakie

R = 1000e3                  # ice disc radius (m)
H = 1e3                     # ice disc thickness (m)
Hice = uniform_ice_cylinder(Omega, R, H)
t_out = years2seconds.([0.0, 200.0, 600.0, 2000.0, 5000.0, 10_000.0, 50_000.0])
interactive_sealevel = false

fip = FastIsoProblem(Omega, c, p, t_out, interactive_sealevel, Hice)
solve!(fip)
function plot3D(fip, k_idx)
    X, Y, out = Array(fip.Omega.X), Array(fip.Omega.Y), fip.out
    zl = extrema(out.ue[end] + out.u[end])
    fig = Figure(fontsize = 10)
    for j in eachindex(k_idx)
        ax = Axis3(fig[1, j])
        u_tot = out.ue[k_idx[j]] + out.u[k_idx[j]]
        surface!(ax, X, Y, u_tot, colormap = :cool)
        wireframe!(ax, X, Y, u_tot, color = :black, linewidth = 0.1)
        zlims!(ax, zl)
    end
    return fig
end
plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>... and here goes the total displacement at <span>$t = 50 \, \mathrm{kyr}$</span>! You can now access the elastic and viscous displacement at time <code>t_out[k]</code> by respectively calling <code>fip.out.ue[k]</code> and <code>fip.out.u[k]</code>. For the present case, the latter can be compared to an analytic solution that is known for this particular case. Let&#39;s look at the accuracy of our numerical scheme over time by running following plotting commands:</p><pre><code class="language-julia hljs">fig = Figure(fontsize = 10)
ax = Axis(fig[1, 1])
cmap = cgrad(:jet, length(t_out), categorical = true)
ii, jj = Omega.Mx:Omega.Nx, Omega.My
x = Omega.X[ii, jj]
r = Omega.R[ii, jj]

# A support vector for computing the analytical solution
vsupport = vcat(1.0e-14, 10 .^ (-10:0.05:-3), 1.0)

for k in eachindex(t_out)
    analytic_solution_r(r) = analytic_solution(r, t_out[k], c, p, H, R, vsupport)
    u_analytic = analytic_solution_r.(r)
    u_numeric = fip.out.u[k][ii, jj]
    lines!(ax, x, u_analytic, color = cmap[k], linewidth = 5,
        label = L&quot;$u_{ana}(t = %$(round(seconds2years(t_out[k]))) \, \mathrm{yr})$&quot;)
    lines!(ax, x, u_numeric, color = cmap[k], linewidth = 5, linestyle = :dash,
        label = L&quot;$u_{num}(t = %$(round(seconds2years(t_out[k]))) \, \mathrm{yr})$&quot;)
end
axislegend(ax, position = :rb, nbanks = 2, patchsize = (50.0f0, 20.0f0))
fig</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>That looks pretty good! One might however object that the convenience function <a href="@ref"><code>fastisostasy</code></a> ends up being not so convenient as soon as the ice load changes over time. This case can however be easily handled, as shown in the next section.</p><h3 id="GPU-support"><a class="docs-heading-anchor" href="#GPU-support">GPU support</a><a id="GPU-support-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-support" title="Permalink"></a></h3><p>For about <span>$n &gt; 6$</span>, the previous example can be computed even faster by using GPU parallelism. It could not represent less work from the user&#39;s perspective, as it boils down to calling <a href="../APIref/#FastIsostasy.ComputationDomain"><code>ComputationDomain</code></a> with an extra keyword argument and passing it to a <code>::LateralVariability</code> with the viscosity and depth values defined earlier:</p><pre><code class="language-julia hljs">n = 7
Omega = ComputationDomain(W, n, use_cuda = true)
p = LateralVariability(Omega, layer_viscosities = lv, layer_boundaries = lb)
Hice = uniform_ice_cylinder(Omega, R, H)
fip = FastIsoProblem(Omega, c, p, t_out, interactive_sealevel, Hice)
solve!(fip)
plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>That&#39;s it, nothing more! For postprocessing, consider using <a href="@ref"><code>reinit_structs_cpu</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Only CUDA supported!</header><div class="admonition-body"><p>For now only Nvidia GPUs are supported and there is no plan of extending this compatibility at this point.</p></div></div><h2 id="Make-your-own-time-loop"><a class="docs-heading-anchor" href="#Make-your-own-time-loop">Make your own time loop</a><a id="Make-your-own-time-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Make-your-own-time-loop" title="Permalink"></a></h2><p>As any high-level function, <a href="../APIref/#FastIsostasy.solve!"><code>solve!</code></a> has some limitations. An ice-sheet modeller typically wants to embed FastIsostasy within a time-stepping loop. This can be easily done by getting familiar with some intermediate-level functions like <a href="@ref"><code>init</code></a>, <a href="../APIref/#FastIsostasy.step!"><code>step!</code></a> and <a href="@ref"><code>write_out!</code></a>:</p><pre><code class="language-julia hljs">Omega = ComputationDomain(3000e3, 6)
p = LateralVariability(Omega)
Hice = uniform_ice_cylinder(Omega, R, H)
fip = FastIsoProblem(Omega, c, p, t_out, interactive_sealevel, Hice)

update_diagnostics!(fip.geostate.dudt, fip.geostate.u, fip, 0.0)
write_out!(fip, 1)
ode = init(fip)
@inbounds for k in eachindex(fip.out.t)[2:end]
    step!(fip, ode, (fip.out.t[k-1], fip.out.t[k]))
    write_out!(fip, k)
end
plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><div class="admonition is-info"><header class="admonition-header">Coupling to julia Ice-Sheet model</header><div class="admonition-body"><p>In case your Ice-Sheet model is programmed in julia, we highly recommend performing the coupling within the function updating the derivatives and let <code>OrdinaryDiffEq.jl</code> handle the rest.</p></div></div><div class="admonition is-info"><header class="admonition-header">GPU not supported</header><div class="admonition-body"><p><code>step!</code> does not support GPU computation so far. Make sure your model is initialized on CPU!</p></div></div><h2 id="Antarctic-deglaciation"><a class="docs-heading-anchor" href="#Antarctic-deglaciation">Antarctic deglaciation</a><a id="Antarctic-deglaciation-1"></a><a class="docs-heading-anchor-permalink" href="#Antarctic-deglaciation" title="Permalink"></a></h2><p>We now want to provide an example that presents:</p><ul><li>a heterogeneous lithosphere thickness</li><li>a heterogeneous upper-mantle viscosity</li><li>various viscous channels</li><li>a more elaborate load that evolves over time</li><li>changes in the sea-level</li></ul><p>For this we run a deglaciation of Antarctica with lithospheric thickness and upper-mantle viscosity from <sup class="footnote-reference"><a id="citeref-Wiens2021" href="#footnote-Wiens2021">[Wiens2021]</a></sup> and the ice thickness history from <sup class="footnote-reference"><a id="citeref-Briggs2014" href="#footnote-Briggs2014">[Briggs2014]</a></sup>. Since the load is known and the isostatic response does not influence it (one-way coupling), we can provide snapshots of the ice thickness and their associated time to <a href="../APIref/#FastIsostasy.FastIsoProblem"><code>FastIsoProblem</code></a>. Under the hood, an interpolator is created and called within the time integration. </p><pre><code class="language-julia hljs">W = 3000e3      # (m) half-width of the domain
n = 7           # implies an NxN grid with N = 2^n = 128.
Omega = ComputationDomain(W, n)
c = PhysicalConstants()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Inversion-of-viscosity-field"><a class="docs-heading-anchor" href="#Inversion-of-viscosity-field">Inversion of viscosity field</a><a id="Inversion-of-viscosity-field-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion-of-viscosity-field" title="Permalink"></a></h2><p>FastIsostasy.jl relies on simplification of the full problem and might therefore need a calibration step to match the data, typically obtained from observations or from a &quot;golden-standard&quot; 3D GIA model. By means of an unscented Kalman inversion, one can e.g. infer the appropriate field of effective mantle viscosity that matches the data best. Whereas this is known to be a tedious step, FastIsostasy is developped to ease the procedure by providing a convenience struct <a href="@ref"><code>Paraminversion</code></a> that can be run by:</p><pre><code class="language-julia hljs">Omega = ComputationDomain(3000e3, 6)
lb = [88e3, 180e3, 280e3, 400e3]
lv = get_wiens_layervisc(Omega)
p = LateralVariability(Omega, layer_boundaries = lb, layer_viscosities = lv)
R, H = 2000e3, 1e3
Hcylinder = uniform_ice_cylinder(Omega, R, H)
Hice = [Hcylinder for t in t_out]
t_out = years2seconds.(1_000.0:1_000.0:2_000.0)
fip = FastIsoProblem(Omega, c, p, t_out, interactive_sealevel, Hice)
solve!(fip)
ground_truth = copy(p.effective_viscosity)

config = InversionConfig()
data = InversionData(t_out, fip.out.u, Hice, config)
paraminv = ParamInversion(Omega, c, p, config, data)
priors, ukiobj = perform(paraminv)
logeta, Gx, e_mean, e_sort = extract_inversion(priors, ukiobj, paraminv)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Wiens2021"><a class="tag is-link" href="#citeref-Wiens2021">Wiens2021</a>Douglas Wiens et al. (2021): <a href="https://doi.org/10.1144/M56-2020-18">The seismic structure of the Antarctic upper mantle</a></li><li class="footnote" id="footnote-Briggs2014"><a class="tag is-link" href="#citeref-Briggs2014">Briggs2014</a>Robert Briggs et al. (2014): <a href="https://doi.org/10.1016/j.quascirev.2014.09.003">A data constrained large ensemble analysis of Antarctic evolution since the Eemian</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../introGIA/">« A quick introduction to GIA</a><a class="docs-footer-nextpage" href="../APIref/">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 15 August 2023 15:17">Tuesday 15 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
