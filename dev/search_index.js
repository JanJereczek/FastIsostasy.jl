var documenterSearchIndex = {"docs":
[{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"EditURL = \"glacialcycle.jl\"","category":"page"},{"location":"examples/glacialcycle/#Glacial-cycle","page":"Glacial cycle","title":"Glacial cycle","text":"","category":"section"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"We now want to provide an example that presents:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"a heterogeneous lithosphere thickness,\na heterogeneous upper-mantle viscosity,\na stack of few viscous channels,\na more elaborate load that evolves over time,\ntransient changes of the relative sea-level.","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"For this we run a glacial cycle of Antarctica with lithospheric thickness and upper-mantle viscosity from Wiens et al. (2022) and the ice thickness history from Peltier et al. (2018). We start by generating a ComputationDomain with intermediate resolution for the sake of the example and load the heterogeneous lithospheric from Pan et al. (2022) thanks to the convenience of load_dataset:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"using CairoMakie, FastIsostasy\n\nN = 140     # corresponds to 50 km resolution\nOmega = ComputationDomain(3500e3, 3500e3, N, N)\n(; Lon, Lat) = Omega\nc = PhysicalConstants()\n\n(_, _), Tpan, Titp = load_dataset(\"Lithothickness_Pan2022\")\nTlitho = Titp.(Lon, Lat) .* 1e3                     # convert from m to km\n\nfunction nicer_heatmap(X)\n    fig = Figure(size = (800, 700))\n    ax = Axis(fig[1, 1], aspect = DataAspect())\n    hidedecorations!(ax)\n    hm = heatmap!(ax, X)\n    Colorbar(fig[1, 2], hm, height = Relative(0.6))\n    return fig\nend\nnicer_heatmap(Tlitho)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"In a similar way, we can load the log-viscosity field from Pan et al. (2022) and plot it at about 300 km depth","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"(_, _, _), _, logeta_itp = load_dataset(\"Viscosity_Pan2022\")\nlogeta300 = logeta_itp.(Lon, Lat, c.r_equator - 300e3)\nnicer_heatmap(logeta300)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"The number of layers and the depth of viscous half-space are arbitrary parameters that have to be defined by the user. We here use a relatively shallow model (half-space begins at 300 km depth) with 1 equalisation layer and 3 intermediate layers:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"mindepth = maximum(Tlitho) + 1e3\nlb_vec = range(mindepth, stop = 300e3, length = 3)\nlb = cat(Tlitho, [fill(lbval, Omega.Nx, Omega.Ny) for lbval in lb_vec]..., dims=3)\n\nrlb = c.r_equator .- lb\nnlb = size(rlb, 3)\nlv_3D = 10 .^ cat([logeta_itp.(Lon, Lat, rlb[:, :, k]) for k in 1:nlb]..., dims=3)\nsize(lv_3D)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"To prevent extreme values of the viscosity, we require it to be larger than a minimal value, fixed to be $10^{16} \\, \\mathrm{Pa \\, s} $. We subsequently generate a LayeredEarth that embeds all the information that has been loaded so far:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"eta_lowerbound = 1e16\nlv_3D[lv_3D .< eta_lowerbound] .= eta_lowerbound\np = LayeredEarth(Omega, layer_boundaries = lb, layer_viscosities = lv_3D)\nnicer_heatmap(log10.(p.effective_viscosity))","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"We now load the ice thickness history from ICE6G, again helped by the convenience of load_dataset. We then create a vector of anomaly snapshots, between which FastIsostasy automatically interpolates linearly. To get an idea of ICE6G, the ice thickness anomaly is then visualised at LGM:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"(lon, lat, t), Hice, Hitp = load_dataset(\"ICE6G_D\")\nHice_vec = [Hitp.(Lon, Lat, tk) for tk in t]\nnicer_heatmap(Hitp.(Lon, Lat, -26) - Hitp.(Lon, Lat, 0))","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"Finally, we define and solve the resulting FastIsoProblem. We hereby choose the verbose=true option to track the progress of the computation.","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"opts = SolverOptions(verbose = true)\ntyr = t .* 1e3\nfip = FastIsoProblem(Omega, c, p, tyr, tyr, Hice_vec, output = \"sparse\", opts = opts)\nsolve!(fip)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"For a resolution of 50 km, the computation time of this last step is less than a minute on a modern i7 (Intel i7-10750H CPU @ 2.60GHz)! We visualise three snapshots of displacements that roughly correspond to LGM, the end of the meltwater pulse 1A and the present-day:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"tplot = [-26, -12, 0]\nfig = Figure(size = (1200, 400))\nopts = ( colormap = :PuOr, colorrange = (-400, 400) )\nfor k in eachindex(tplot)\n    kfi = argmin( abs.(tplot[k] * 1e3 .- tyr) )\n    ax = Axis(fig[1, k], aspect = DataAspect(), title = \"t = $(t[kfi]) kyr\")\n    hidedecorations!(ax)\n    heatmap!(ax, fip.out.u[kfi] + fip.out.ue[kfi]; opts...)\n    println(kfi)\nend\nColorbar(fig[1, 4], height = Relative(0.6); opts...)\nfig","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"The displayed fields are displacement anomalies w.r.t. to the last interglacial, defined as the reference for the ice thickness anomalies. In Swierczek-Jereczek et al. (2024) these computations are performed on a finer grid, with an interactive sea level, and show great agreement with a 3D GIA model that runs between 10,000-100,000 slower (however at with advantage of obtaining a global and richer output).","category":"page"},{"location":"references/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"references/","page":"Bibliography","title":"Bibliography","text":"Bueler, E.; Lingle, C. S. and Brown, J. (2007). Fast computation of a viscoelastic deformable Earth model for ice-sheet simulations. Annals of Glaciology 46, 97–105. Accessed on Nov 15, 2022.\n\n\n\nCathles, L. M. (1975). Viscosity of the Earth's Mantle (Princeton University Press).\n\n\n\nHuang, D. Z. and Huang, J. (Feb 2021). Improve Unscented Kalman Inversion With Low-Rank Approximation and Reduced-Order Model. Accessed on Sep 22, 2023, arXiv:2102.10677 [cs, math].\n\n\n\nIvins, E. R.; van der Wal, W.; Wiens, D. A.; Lloyd, A. J. and Caron, L. (2022). Antarctic upper mantle rheology. Geological Society, London, Memoirs 56, M56–2020–19. Accessed on Nov 29, 2022.\n\n\n\nLingle, C. S. and Clark, J. A. (1985). A numerical model of interactions between a marine ice sheet and the solid earth: Application to a West Antarctic ice stream. Journal of Geophysical Research 90, 1100. Accessed on Nov 23, 2022.\n\n\n\nPan, L.; Milne, G. A.; Latychev, K.; Goldberg, S. L.; Austermann, J.; Hoggard, M. J. and Mitrovica, J. X. (2022). The influence of lateral Earth structure on inferences of global ice volume during the Last Glacial Maximum. Quaternary Science Reviews 290, 107644. Accessed on Oct 4, 2023.\n\n\n\nPeltier, W. R.; Argus, D. F. and Drummond, R. (2018). Comment on “An Assessment of the ICE‐6G_C (VM5a) Glacial Isostatic Adjustment Model” by Purcell et al. Journal of Geophysical Research: Solid Earth 123, 2019–2028. Accessed on Sep 21, 2023.\n\n\n\nSwierczek-Jereczek, J.; Montoya, M.; Latychev, K.; Robinson, A.; Alvarez-Solas, J. and Mitrovica, J. (2024). FastIsostasy v1. 0–a regional, accelerated 2D glacial isostatic adjustment (GIA) model accounting for the lateral variability of the solid Earth. Geoscientific Model Development 17, 5263–5290.\n\n\n\nWhitehouse, P. L.; Gomez, N.; King, M. A. and Wiens, D. A. (2019). Solid Earth change and the evolution of the Antarctic Ice Sheet. Nature Communications 10, 503. Accessed on Nov 15, 2022.\n\n\n\nWiens, D. A.; Shen, W. and Lloyd, A. J. (2022). The seismic structure of the Antarctic upper mantle. Geological Society, London, Memoirs 56, M56–2020–18. Accessed on Dec 1, 2022.\n\n\n\n","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"EditURL = \"inversion.jl\"","category":"page"},{"location":"examples/inversion/#Parameter-inversion","page":"Parameter inversion","title":"Parameter inversion","text":"","category":"section"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"Assume a dynamical system f generates an output y based on its input x and on a set of parameters theta. The goal of a parameter inversion is to estimate the parameters theta that best fit the data haty with respect to an error metric Psi, i.e. to solve the following optimization problem:","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"beginaligned\ny = f(x theta) \nhattheta = argmin_theta Psi(haty - y)\nendaligned","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"Since FastIsostasy relies on simplifications of the full GIA problem, applying such inversion can be useful to tune the model parameters (upper-mantle viscosity field, lithospheric thickness... etc.) such that the output y (typically the displacement) matches the data haty (typically obtained from observations or from a 3D GIA model). There are many ways of solving this problem, among which the use of Kalman filtering techniques. FastIsostasy.jl provides convenience functions for the latter by wrapping the functionalities of EnsembleKalmanProcesses.jl in an external routine that is automatically loaded when using EnsembleKalmanProcesses.","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"We demonstrate the tuning of the effective viscosity in a region that is being forced by a circular ice load. We emphasise that the highlighted tools provided by FastIsostasy are not limited to this case. As it will be made clear throughout the example, the user merely needs to define their own ParameterReduction and the associated behaviours of reconstruct! and extract_output to adapt the inversion procedure to their needs (e.g. tune lithospheric thickness throughout the whole domain).","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"note: Resolution\nWe perform the following analysis on a low-resolution grid. High resolutions (ca. Omega.Nx = Omega.Ny > 200) are difficult to achieve since the underlying unscented Kalman filter requires many simulations. This is however typically not a problem, since the parametric fields (here the viscosity) are smooth and can be downsampled without significant loss of information.","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"We first load the necessary packages, initialize the ComputationDomain and assign laterally-variable viscosity profiles to a LayeredEarth by loading the fields estimated in Wiens et al. (2022):","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"using CairoMakie\nusing Distributions\nusing EnsembleKalmanProcesses\nusing EnsembleKalmanProcesses.ParameterDistributions\nusing FastIsostasy\nusing LinearAlgebra\n\nOmega = ComputationDomain(3000e3, 5)\nc = PhysicalConstants()\nlb = [100e3, 200e3, 300e3]\n_, eta, eta_itp = load_dataset(\"Wiens2022\")\nloglv = cat([eta_itp.(Omega.X, Omega.Y, z) for z in lb]..., dims = 3)\nlv = 10 .^ loglv\np = LayeredEarth(Omega, layer_boundaries = lb, layer_viscosities = lv)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"To make this problem more exciting, we place the center of the ice load to (-1000 -1000)  mathrmkm where the viscosity field displays a less uniform structure. For the sake of simplicity, the data to fit is obtained from a FastIsostasy simulation with the ground-truth viscosity field.","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"R, H = 1000e3, 1e3\nHcylinder = uniform_ice_cylinder(Omega, R, H, center = [-1000e3, -1000e3])\nHice = [zeros(Omega.Nx, Omega.Ny), Hcylinder, Hcylinder]\nt_out = collect(1e3:1e3:2e3)\npushfirst!(t_out, t_out[1]-1e-8)\nt_Hice = copy(t_out)\n\ntrue_viscosity = copy(p.effective_viscosity)\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice, output = \"sparse\")\nsolve!(fip)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"Assuming the result of this simulation to be the ground truth haty, we can now build an InversionData object that will be passed to an InversionProblem. The InversionData object contains the time series of the input field X = Hice and the output field Y = extract_fip(fip) (here the displacement field). Furthermore, we define an InversionConfig that uses the unscented Kalman filter as introduced in Huang and Huang (Feb 2021).","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"X = Hice\nmask3D = cat([x .> 0 for x in X]..., dims = 3)\nmask = reduce(|, mask3D, dims = 3)[:, :, 1]     # Only tune viscosity where there is ice.\n\nt_inv = t_out[end:end]                          # Only use last time step for inversion.\nextract_last_viscous_displacement(fip) = fip.out.u[end:end]\nextract_fip = extract_last_viscous_displacement\nY = extract_fip(fip)\n\ndata = InversionData(t_inv, length(t_inv), X, Y, mask, count(mask))\nconfig = InversionConfig(Unscented, N_iter = 15, scale_obscov = 10.0)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"Before finalising the inversion, we need to specify a ParameterReduction, which allows a multiple dispatch of reconstruct!, extract_output and (optionally) print_inversion_evolution. This allows the inversion procedure to update the parameters, extract the relevant output and (optionally) print out meaningful information over the iterations of the inversion procedure. In this example, we define a ViscosityRegion that reduces the number of parameters to the number of grid points in the mask.","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"struct ViscosityRegion{T<:AbstractFloat} <: ParameterReduction{T}\n    mask::BitMatrix\n    nparams::Int\nend\n\nfunction FastIsostasy.reconstruct!(fip, params, reduction::ViscosityRegion)\n    fip.p.effective_viscosity[reduction.mask] .= 10 .^ params\nend\n\nfunction FastIsostasy.extract_output(fip, reduction::ViscosityRegion, data::InversionData)\n    return extract_fip(fip)[1][reduction.mask]\nend\n\nfunction FastIsostasy.print_inversion_evolution(paraminv, n, ϕ_n, reduction::ViscosityRegion)\n    err_n = paraminv.error[n]\n    cov_n = paraminv.ukiobj.process.uu_cov[n]\n\n    println(\"-----------------------------------------------------\")\n    println(\"Inversion being performed with $(typeof(reduction)) as a parameter reduction\")\n    @show size(ϕ_n), n, err_n, norm(cov_n)\n    println(\"Mean tuned log10-viscosity: $(round(mean(ϕ_n), digits = 3))\")\n    println(\"Extrema of tuned log10-viscosity: $(extrema(ϕ_n))\")\n    return nothing\nend\n\nreduction = ViscosityRegion{Float64}(mask, count(mask))","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"We can now proceed to the definition of the InversionProblem with a prior distribution that is a Gaussian with mean 205, variance 05 and bounds 190 220. We then check the initialisation of the inversion problem by reconstructing the field with the prior parameters:","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"priors = combine_distributions([constrained_gaussian( \"p_$(i)\",\n    20.5, 0.5, 19.0, 22.0) for i in 1:reduction.nparams])\nparaminv = inversion_problem(deepcopy(fip), config, data, reduction, priors)\n\nparams = fill(20.5, count(mask))\nreconstruct!(paraminv.fip, params, reduction)\nfunction plot_viscfields(paraminv)\n    cmap = cgrad(:jet, rev = true)\n    crange = (19.5, 21.5)\n    fig = Figure(size = (1800, 1000), fontsize = 40)\n    axs = [Axis(fig[1,i], aspect = DataAspect()) for i in 1:2]\n    [hidedecorations!(ax) for ax in axs]\n    heatmap!(axs[1], log10.(true_viscosity), colormap = cmap, colorrange = crange)\n    heatmap!(axs[2], log10.(paraminv.fip.p.effective_viscosity),\n        colormap = cmap, colorrange = crange)\n    Colorbar(fig[2, :], vertical = false, colormap = cmap, colorrange = crange,\n        width = Relative(0.5))\n    return fig\nend\nfig1 = plot_viscfields(paraminv)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"Finally, we solve the inversion problem and visualise the results.","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"solve!(paraminv)\nfig2 = plot_viscfields(paraminv)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this section, we will present some examples with idealised loads and solid-Earth parameters. This should give the user a basic understanding of FastIsostasy's basic functions.","category":"page"},{"location":"examples/tutorial/#3D-2D-Earth","page":"Tutorial","title":"3D ➡ 2D Earth","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"FastIsostasy relies on a (polar) stereographic projection. Let's first create Omega::ComputationDomain and visualise how this relates to a domain on a spherical Earth:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie, FastIsostasy\n\nW = 3000e3      # (m) half-width of the domain Wx = Wy\nn = 7           # implies an Nx x Ny grid with Nx = Ny = 2^n = 128.\nOmega = ComputationDomain(W, n)\nfig = Figure(size = (1600, 800), fontsize = 24)\nax1 = Axis3(fig[1, 1], title = \"Original grid\")\nax2 = Axis3(fig[1, 2], title = \"Projected grid\")\nwireframe!(ax1, Omega.X .* Omega.K, Omega.Y .* Omega.K,\n    Omega.R .* cos.(deg2rad.(Omega.Lat)), color = :gray10, linewidth = 0.1)\nwireframe!(ax2, Omega.X .* Omega.K, Omega.Y .* Omega.K,\n    Omega.null, color = :gray10, linewidth = 0.1)\nfor ax in [ax1, ax2]\n    zlims!(ax, (0, 5e6))\n    hidedecorations!(ax)\n    hidespines!(ax)\nend\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Using other projections\nFor now, FastIsostasy only supports the polar stereographic projection. Future releases will allow the user to define their own projection.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The projection allows to treat the radially-layered, onion-like structure of the solid Earth as a superposition of horizontal layers. Furthermore, FastIsostasy reduces this 3D problem into a 2D problem by collapsing the depth dimension, mainly through the computation of an effective viscosity field that accounts for the superposition of layers with different viscosities. The user is required to provide the 3D information, which will then be used under the hood to compute the effective viscosity. This tutorial shows such an example.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We want to render a situation similar to the one depicted below:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Schematic representation of the three-layer set-up.)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Initializing a LayeredEarth with parameters corresponding to this situation automatically computes the conversion from a 3D to a 2D problem. Since we will compare our solution to an analytical one of a flat Earth, we exceptionally switch off the distortion correction, which accounts for the distortion factor Omega.K in the computation. This can be simply executed by running:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Omega = ComputationDomain(W, n, correct_distortion = false)\nc = PhysicalConstants()\nlv = [1e19, 1e21]       # viscosity layers (Pa s)\nlb = [88e3, 400e3]      # depth of layer boundaries (m)\np = LayeredEarth(Omega, layer_viscosities = lv, layer_boundaries = lb, rho_litho = 0.0)\nextrema(p.effective_viscosity)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the effective viscosity is a homogeneous field. It corresponds to a nonlinear mean of the layered values provided by the user. Note that we have set rho_litho = 0 to prevent the lithosphere from contributing to the hydrostatic pressure term, such that the numerical solution obtained here is comparable with the analytical one provided in Bueler et al. (2007). The default value however yields rho_litho = 3200  mathrmkgm^3 and contributes to the hydrostatic pressure term.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The next section shows how to use the now obtained p::LayeredEarth for actual GIA computation.","category":"page"},{"location":"examples/tutorial/#Simple-load-and-geometry","page":"Tutorial","title":"Simple load and geometry","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We now apply a constant load, here a cylinder of ice with radius R = 1000  mathrmkm and thickness H = 1  mathrmkm, over Omega::ComputationDomain introduced in LayeredEarth. To formulate the problem conviniently, we use FastIsoProblem, a struct containing the variables and options that are necessary to perform the integration over time. We can then simply apply solve!(fip::FastIsoProblem) to perform the integration of the ODE. Under the hood, the ODE is obtained from the PDE by applying a Fourier collocation scheme contained in lv_elva!. The integration is performed according to FastIsoProblem.diffeq::NamedTuple, which contains the algorithm and optionally tolerances, maximum iteration number... etc.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"t_out = [0.0, 2e2, 6e2, 2e3, 5e3, 1e4, 5e4]     # vector of output time steps (yr)\nεt = 1e-8\npushfirst!(t_out, -εt)                          # append step to have Heaviside at t=0\n\nR = 1000e3                                      # ice disc radius (m)\nH = 1e3                                         # ice disc thickness (m)\nHcylinder = uniform_ice_cylinder(Omega, R, H)   # field representing ice disk\n\nt_Hice = [-εt, 0.0, t_out[end]]                 # ice history = Heaviside at t=0\nHice = [zeros(Omega.Nx, Omega.Ny), Hcylinder, Hcylinder]\n\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice, output = \"sparse\")\nsolve!(fip)\n\nfunction plot3D(fip, k_idx)\n    X, Y, out = Array(fip.Omega.X), Array(fip.Omega.Y), fip.out\n    zl = extrema(out.ue[end] + out.u[end])\n    fig = Figure(fontsize = 10)\n    for j in eachindex(k_idx)\n        ax = Axis3(fig[1, j])\n        u_tot = out.ue[k_idx[j]] + out.u[k_idx[j]]\n        surface!(ax, X, Y, u_tot, colormap = :cool)\n        wireframe!(ax, X, Y, u_tot, color = :black, linewidth = 0.1)\n        zlims!(ax, zl)\n    end\n    return fig\nend\nfig = plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The figure above shows the total displacement at t = 06  mathrmkyr and t = 50  mathrmkyr. Since we defined output = \"sparse\", we can now access the elastic and viscous displacement at time t_out[k] by calling fip.out.ue[k] and fip.out.u[k]. For the present case, the latter can be compared to an analytic solution that is known for this particular case. Let's look at the accuracy of our numerical scheme over time by running following plotting commands:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"fig = Figure()\nax = Axis(fig[1, 1])\ncmap = cgrad(:jet, length(t_out), categorical = true)\nii, jj = Omega.Mx:Omega.Nx, Omega.My\nx = Omega.X[ii, jj]\nr = Omega.R[ii, jj]\n\nfor k in eachindex(t_out)[2:end]\n    analytic_solution_r(r) = analytic_solution(r, years2seconds(t_out[k]),\n        c, p, H, R)\n    u_analytic = analytic_solution_r.(r)\n    u_numeric = fip.out.u[k][ii, jj]\n    lines!(ax, x, u_analytic, color = cmap[k], linewidth = 5,\n        label = L\"$u_{ana}(t = %$(t_out[k]) \\, \\mathrm{yr})$\")\n    lines!(ax, x, u_numeric, color = cmap[k], linewidth = 5, linestyle = :dash,\n        label = L\"$u_{num}(t = %$(t_out[k]) \\, \\mathrm{yr})$\")\nend\naxislegend(ax, position = :rb, patchsize = (50.0f0, 20.0f0))\nfig","category":"page"},{"location":"examples/tutorial/#GPU-support","page":"Tutorial","title":"GPU support","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"For about n geq 7, the present example can be computed even faster by using GPU parallelism. It could not represent less work from the user's perspective, as it boils down to calling ComputationDomain with an extra keyword argument:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Omega = ComputationDomain(W, n, use_cuda = true)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We then pass Omega to a LayeredEarth and a FastIsoProblem, which we solve as done above: that's it!","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Only CUDA supported!\nFor now only Nvidia GPUs are supported and there is no plan of extending this compatibility at this point.","category":"page"},{"location":"examples/tutorial/#Make-your-own-time-loop","page":"Tutorial","title":"Make your own time loop","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"As any high-level function, solve! has some limitations. An ice-sheet modeller typically wants to embed FastIsostasy within a time-stepping loop. This can be easily done by getting familiar with some intermediate-level functions like init, step! and write_out!:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Omega = ComputationDomain(3000e3, n)\np = LayeredEarth(Omega)\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice, output = \"sparse\")\n\nupdate_diagnostics!(fip.now.dudt, fip.now.u, fip, 0.0)\nwrite_out!(fip.out, fip.now, 1)\node = init(fip)\n@inbounds for k in eachindex(fip.out.t)[2:end]\n    step!(fip, ode, (fip.out.t[k-1], fip.out.t[k]))\n    write_out!(fip.out, fip.now, k)\nend\nfig = plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Limited GPU support\nstep! does not support GPU computation so far. Make sure your model is initialized on CPU.","category":"page"},{"location":"examples/tutorial/#Using-different-deformation-models","page":"Tutorial","title":"Using different deformation models","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"ELRA is a GIA model that is commonly used in ice-sheet modelling. For the vast majority of applications, it is less accurate than LV-ELVA without providing any significant speed up (Swierczek-Jereczek et al., 2024). However, it can be used by specifying adequate options:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"p = LayeredEarth(Omega, tau = 3e3)\nopts = SolverOptions(deformation_model = :elra)\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice, opts = opts, output = \"sparse\")\nsolve!(fip)\nfig = plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The reader may have noticed that the equilibrium displacement (at t = 50  mathrmkyr) given by ELRA is the same as the one given by LV-ELVA, although their transient behaviour differ (e.g. at t = 06  mathrmkyr). This is expected when the lithosphere yields a constant thickness but breaks down when the lithosphere thickness varies.","category":"page"},{"location":"fortran/#Fortran-version","page":"Fortran version","title":"Fortran version","text":"","category":"section"},{"location":"fortran/","page":"Fortran version","title":"Fortran version","text":"Since Julia does not allow compilation to binaries yet, some researchers might find it hard to couple FastIsostasy.jl to their favourite ice-sheet model. To tackle this, a Fortran version has been developed. It however lacks some features, which are summarised below:","category":"page"},{"location":"fortran/","page":"Fortran version","title":"Fortran version","text":"Library of time-integration methods reduced to explicit Euler,\nOnly fixed time stepping allowed,\nNo inversion routines for the UKI,\nComputation on GPU not supported.","category":"page"},{"location":"fortran/","page":"Fortran version","title":"Fortran version","text":"These discrepancies are unlikely to be gapped in the future, mostly because the Fortran ecosystem is less extensive than the Julia one.","category":"page"},{"location":"APIref/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"APIref/#Basic-structs","page":"API reference","title":"Basic structs","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"ComputationDomain\nPhysicalConstants\nLayeredEarth\nReferenceState\nCurrentState\nFastIsoTools\nSolverOptions\nOceanSurfaceChange\nFastIsoProblem","category":"page"},{"location":"APIref/#FastIsostasy.ComputationDomain","page":"API reference","title":"FastIsostasy.ComputationDomain","text":"ComputationDomain\nComputationDomain(W, n)\nComputationDomain(Wx, Wy, Nx, Ny)\n\nReturn a struct containing all information related to geometry of the domain and potentially used parallelism. To initialize one with 2*W and 2^n grid cells:\n\nOmega = ComputationDomain(W, n)\n\nIf a rectangular domain is needed, run:\n\nOmega = ComputationDomain(Wx, Wy, Nx, Ny)\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.PhysicalConstants","page":"API reference","title":"FastIsostasy.PhysicalConstants","text":"PhysicalConstants\n\nReturn a struct containing important physical constants. Comes with default values that can however be changed by the user, for instance by running:\n\nc = PhysicalConstants(rho_ice = 0.93)   # (kg/m^3)\n\nAll constants are given in SI units (kilogram, meter, second).\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.LayeredEarth","page":"API reference","title":"FastIsostasy.LayeredEarth","text":"LayeredEarth(Omega; layer_boundaries, layer_viscosities)\n\nReturn a struct containing all information related to the lateral variability of solid-Earth parameters. To initialize with values other than default, run:\n\nOmega = ComputationDomain(3000e3, 7)\nlb = [100e3, 300e3]\nlv = [1e19, 1e21]\np = LayeredEarth(Omega, layer_boundaries = lb, layer_viscosities = lv)\n\nwhich initializes a lithosphere of thickness T_1 = 100 mathrmkm, a viscous channel between T_1and T_2 = 200 mathrmkmand a viscous halfspace starting at T_2. This represents a homogenous case. For heterogeneous ones, simply make lb::Vector{Matrix}, lv::Vector{Matrix} such that the vector elements represent the lateral variability of each layer on the grid of Omega::ComputationDomain.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.ReferenceState","page":"API reference","title":"FastIsostasy.ReferenceState","text":"ReferenceState\n\nReturn a struct containing the reference state.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.CurrentState","page":"API reference","title":"FastIsostasy.CurrentState","text":"CurrentState\n\nReturn a mutable struct containing the geostate which will be updated over the simulation. The geostate contains all the states of the [FastIsoProblem] to be solved.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.FastIsoTools","page":"API reference","title":"FastIsostasy.FastIsoTools","text":"FastIsoTools(Omega, c, p)\n\nReturn a struct containing pre-computed tools to perform forward-stepping of the model. This includes the Green's functions for the computation of the lithosphere and the SSH perturbation, plans for FFTs, interpolators of the load and the viscosity over time and preallocated arrays.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.SolverOptions","page":"API reference","title":"FastIsostasy.SolverOptions","text":"Options\n\nReturn a struct containing the options relative to solving a FastIsoProblem.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.OceanSurfaceChange","page":"API reference","title":"FastIsostasy.OceanSurfaceChange","text":"OceanSurfaceChange(; z0 = 0.0)\n\nReturn a mutable struct OceanSurfaceChange containing:\n\nz_k: the GMSL at current time step k.\nA_k: the ocean surface at current time step k.\nz: a vector of GMSL values used as knots for interpolation.\nA: a vector of ocean surface values used as knots for interpolation.\nA_itp: an interpolator of ocean surface over depth. Bias-free for present-day.\nA_pd: the present-day ocean surface.\nres: residual of the nonlinear equation solved numerically.\n\nAn osc::OceanSurfaceChange can be used as function to update osc.z_k and osc.A_k based on osc.A_itp and an input delta_V by running:\n\nosc(delta_V)\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.FastIsoProblem","page":"API reference","title":"FastIsostasy.FastIsoProblem","text":"FastIsoProblem(Omega, c, p, t_out)\nFastIsoProblem(Omega, c, p, t_out, Hice)\nFastIsoProblem(Omega, c, p, t_out, t_Hice, Hice)\n\nReturn a struct containing all the other structs needed for the forward integration of the model over Omega::ComputationDomain with parameters c::PhysicalConstants and p::LayeredEarth. The outputs are stored at t_out::Vector{<:AbstractFloat}.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#Mechanics","page":"API reference","title":"Mechanics","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"solve!(::FastIsoProblem)\ninit\nstep!\nupdate_diagnostics!\nlv_elva!\nupdate_elasticresponse!","category":"page"},{"location":"APIref/#FastIsostasy.solve!-Tuple{FastIsoProblem}","page":"API reference","title":"FastIsostasy.solve!","text":"solve!(fip)\n\nSolve the isostatic adjustment problem defined in fip::FastIsoProblem.\n\n\n\n\n\n","category":"method"},{"location":"APIref/#FastIsostasy.init","page":"API reference","title":"FastIsostasy.init","text":"init(fip)\n\nInitialize an ode::CoupledODEs, aimed to be used in step!.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.step!","page":"API reference","title":"FastIsostasy.step!","text":"step!(fip)\n\nStep fip::FastIsoProblem over tspan and based on ode::CoupledODEs, typically obtained by init.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.update_diagnostics!","page":"API reference","title":"FastIsostasy.update_diagnostics!","text":"update_diagnostics!(dudt, u, fip, t)\n\nUpdate all the diagnotisc variables, i.e. all fields of fip.now apart from the displacement, which requires an integrator.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.lv_elva!","page":"API reference","title":"FastIsostasy.lv_elva!","text":"lv_elva!(dudt, u, fip, t)\n\nUpdate the displacement rate dudt of the viscous response according to LV-ELVA.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.update_elasticresponse!","page":"API reference","title":"FastIsostasy.update_elasticresponse!","text":"update_elasticresponse!(fip::FastIsoProblem)\n\nUpdate the elastic response by convoluting the Green's function with the load anom. To use coefficients differing from [Farrell1972], see FastIsoTools.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#Parameter-inversion","page":"API reference","title":"Parameter inversion","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"InversionConfig\nInversionData\nInversionProblem\ninversion_problem\nParameterReduction\nprint_inversion_evolution\nextract_inversion\nreconstruct!\nextract_output","category":"page"},{"location":"APIref/#FastIsostasy.InversionConfig","page":"API reference","title":"FastIsostasy.InversionConfig","text":"InversionConfig\n\nStruct containing configuration parameters for a [InversionProblem].\n\nFields\n\nmethod::Any: Inversion method to use.\nparamspriors::NamedTuple: Prior information about the parameters to invert.\nN_iter::Int: Number of iterations for the inversion.\nα_reg::Real: Regularization factor. When you have enough observation data α=1 (no regularization)\nupdate_freq::Int: Update frequency for the inversion.\n\n1 : approximate posterior cov matrix with an uninformative prior. 0 : weighted average between posterior cov matrix with an uninformative prior and prior.\n\nn_samples::Int: Number of samples for the inversion.\nscale_obscov::Real: Scaling factor for the observational covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.InversionData","page":"API reference","title":"FastIsostasy.InversionData","text":"InversionData\n\nStruct containing the inversion data.\n\nFields\n\nt::Vector{T}: Time vector.\nnt::Int: Number of time steps.\nX::Vector{M}: Ground truth input (forcing).\nY::Vector{M}: Ground truth response.\nmask::BitMatrix: Region of interest.\ncountmask::Int: count(mask) = number of cells used for inversion.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.InversionProblem","page":"API reference","title":"FastIsostasy.InversionProblem","text":"InversionProblem\n\nStruct containing variables and configs for the inversion of Solid-Earth parameter fields. InversionProblem needs to be initialized using inversion_problem. For now, the unscented Kalman inversion is the only method available.\n\nFields\n\nfip::FastIsoProblem: FastIsoProblem object.\nconfig::InversionConfig: Configuration for the inversion.\ndata::InversionData: Data for the inversion.\nreduction::R: Parameter reduction method.\npriors::PD: Prior distribution.\nukiobj::EKP: Unscented Kalman inversion object.\nerror::V: Error vector.\nout::Vector{V}: Output vector.\nG_ens::M: Ensemble of the covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.inversion_problem","page":"API reference","title":"FastIsostasy.inversion_problem","text":"inversion_problem(fip, config, data, reduction, priors; save_stride_iter::Int = 1)\n\nGenerate an inversion problem for the given fip::FastIsoProblem object.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.ParameterReduction","page":"API reference","title":"FastIsostasy.ParameterReduction","text":"ParameterReduction\n\nAbstract type for parameter reduction methods. Any subtype must implement the reconstruct!(fip, theta) method, which assigns the reconstructed parameter values to fip::FastIsoProblem.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.print_inversion_evolution","page":"API reference","title":"FastIsostasy.print_inversion_evolution","text":"print_inversion_evolution(paraminv, n, ϕ_n, reduction)\n\nPrint the inversion evolution.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.extract_inversion","page":"API reference","title":"FastIsostasy.extract_inversion","text":"extract_inversion(paraminv, n)\n\nExtract the inversion results to compare them with the ground truth.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.reconstruct!","page":"API reference","title":"FastIsostasy.reconstruct!","text":"reconstruct!(fip, params, reduction)\n\nReconstruct the parameter values from reduction and update fip accordingly.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.extract_output","page":"API reference","title":"FastIsostasy.extract_output","text":"extract_output(fip, reduction, data)\n\nExtract the output of the forward run for the inversion.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#Convenience","page":"API reference","title":"Convenience","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"load_dataset\nreinit_structs_cpu\nwrite_out!","category":"page"},{"location":"APIref/#FastIsostasy.load_dataset","page":"API reference","title":"FastIsostasy.load_dataset","text":"load_dataset(name) → (dims), field, interpolator\n\nReturn the dims::Tuple{Vararg{Vector}}, the field<:Array and the interpolator corresponding to a data set defined by a unique name::String. For instance:\n\n(lon180, lat, t), Hice, Hice_itp = load_dataset(\"ICE6G_D\")\n\nFollowing options are available for parameter fields:\n\n\"ICE6GD\": ice loading history from ICE6GD.\n\"Wiens2022\": viscosity field from (Wiens et al. 2022)\n\"Lithothickness_Pan2022\": lithospheric thickness field from (Pan et al. 2022)\n\"Viscosity_Pan2022\": viscosity field from (Pan et al. 2022)\n\nFollowing options are available for model results:\n\n\"Spada2011\"\n\"LatychevGaussian\"\n\"LatychevICE6G\"\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.reinit_structs_cpu","page":"API reference","title":"FastIsostasy.reinit_structs_cpu","text":"reinit_structs_cpu(Omega, p)\n\nReinitialize Omega::ComputationDomain and p::LayeredEarth on the CPU, mostly for post-processing purposes.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.write_out!","page":"API reference","title":"FastIsostasy.write_out!","text":"write_out!(now, out, k)\n\nWrite results in output vectors.\n\n\n\n\n\n","category":"function"},{"location":"#FastIsostasy.jl","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"❄ Fast and friendly glacial isostatic adjustment on CPU and GPU.","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"(Image: GlacialCycle)","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy is a friendly and flexible model that regionally computes the glacial isostatic adjustment (GIA) with laterally-variable mantle viscosity and lithospheric thickness. It is described in Swierczek-Jereczek et al. (2024) and is mainly adressed to ice-sheet modellers who seek for (1) a good representation of solid-Earth mechanics at virtually zero computational cost, (2) an approximation of the sea-level equation and (3) ready-to-use inversion tools to calibrate the model parameters to data. The simple interface of FastIsostasy allows to flexibly solve GIA problems within a few lines of code. The code is distributed under GNU general public license v3 and was succesfully benchmarked against analytical, 1D GIA and 3D GIA model solutions.","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"Based on the work of Cathles (1975) and Lingle and Clark (1985), an efficient way of solving for the vertical displacement was proposed by Bueler et al. (2007). FastIsostasy generalises this approach by relying on a hybrid Fourier/finite-difference collocation. Thanks to a simplification of the full problem from 3D to 2D space and the use of optimized software packages, running kiloyears of regional GIA with Delta x = Delta y = 45  mathrmkm is a matter of seconds on a single CPU. For high resolution runs, the user can switch to GPU usage with minimal syntax change and enjoy the advantage of parallelization without requiring an HPC cluster. For GIA \"purists\", this package is likely to miss interesting processes but we belive that its ridiculous run-time can help to fast-prototype a problem before transfering it to a more comprehensive model.","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"tip: Star us on GitHub!\nIf you have found this library useful, please consider starring it on GitHub. This gives us a lower bound of the satisfied user count.","category":"page"},{"location":"#Getting-started","page":"FastIsostasy.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy.jl is a registered julia package. To install it, please run:","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"using Pkg\nPkg.add(\"FastIsostasy\")","category":"page"},{"location":"#How-to-read-the-docs?","page":"FastIsostasy.jl","title":"How to read the docs?","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"If you want a quick introduction to GIA, please go to Quick intro to GIA. If you want to have a thorough but still accessbile introduction to GIA, we highly recommend reading Whitehouse et al. (2019). If you want to get started right away, feel free to directly go to the Tutorial. If you face any problem using the code or want to know more about the functionalities of the package, visit the API reference. If you face a problem you cannot solve, please open a GitHub issue with a minimal and reproduceable example. We also welcome feature requests!","category":"page"},{"location":"#How-to-cite?","page":"FastIsostasy.jl","title":"How to cite?","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"Swierczek-Jereczek, J., Montoya, M., Latychev, K., Robinson, A., Alvarez-Solas, J., & Mitrovica, J. (2024). FastIsostasy v1.0 – a regional, accelerated 2D glacial isostatic adjustment (GIA) model accounting for the lateral variability of the solid Earth. Geoscientific Model Development, 17(13), 5263-5290.","category":"page"},{"location":"#Juliaecosystem","page":"FastIsostasy.jl","title":"Julia ecosystem","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy.jl was written thanks to the sheer amount of work that people invested in the vast and well-documented Julia ecosystem. Major help from packages deserves major appreciation, in particular for:","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FFTW.jl\nCUDA.jl\nParallelStencil.jl\nInterpolations.jl\nOrdinaryDiffEq.jl\nDynamicalSystemsBase.jl\nKalmanEnsembleProcesses.jl\nSpecialFunctions.jl\nFastGaussQuadrature.jl\nAnd all the fantastic development tools that ease the every-day work so much: Documenter.jl, Literate.jl, Test.jl and DocumenterCitations.jl. Despite being quite unrelated, Oceananigans was a great template of how well geoscientific models can be documented.","category":"page"},{"location":"introGIA/#Quick-intro-to-GIA","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"","category":"section"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"Glacial isostatic adjustment (GIA) denotes the crustal deformation that results from changes in the ice, liquid water and sediment columns, as well as associated changes in Earth's gravity and rotation axis, ultimately impacting the sea level. The magnitude and time scale of the deformational response depends on the applied load and on solid-Earth parameters, i.e. the mantle viscosity, the lithosphere thickness and their respective density. These parameters display a radial and sometimes also a lateral variability. For further details, please refer to Wiens et al. (2022) and Ivins et al. (2022).","category":"page"},{"location":"introGIA/#Why-do-we-care?","page":"Quick intro to GIA","title":"Why do we care?","text":"","category":"section"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"GIA is known to present many feedbacks on ice-sheet evolution (Whitehouse et al., 2019). Their net effect is negative, meaning that GIA inhibits ice-sheet growth and retreat. A good representation of GIA is therefore needed to obtain realistic paleoclimatic reconstructions of ice sheets, as well as reliable projections of future sea level rise due to anthropogenic warming. The effect of GIA in this context appears to be particularly relevant as a large portion of human societies are concentrated along coasts.","category":"page"}]
}
