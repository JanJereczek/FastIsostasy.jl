var documenterSearchIndex = {"docs":
[{"location":"references/#Bibliography","page":"Bibliography","title":"Bibliography","text":"Bueler, E.; Lingle, C. S. and Brown, J. (2007). Fast computation of a viscoelastic deformable Earth model for ice-sheet simulations. Annals of Glaciology 46, 97–105. Accessed on Nov 15, 2022.\n\n\n\nCathles, L. M. (1975). Viscosity of the Earth's Mantle (Princeton University Press).\n\n\n\nIvins, E. R.; van der Wal, W.; Wiens, D. A.; Lloyd, A. J. and Caron, L. (2022). Antarctic upper mantle rheology. Geological Society, London, Memoirs 56, M56–2020–19. Accessed on Nov 29, 2022.\n\n\n\nLingle, C. S. and Clark, J. A. (1985). A numerical model of interactions between a marine ice sheet and the solid earth: Application to a West Antarctic ice stream. Journal of Geophysical Research 90, 1100. Accessed on Nov 23, 2022.\n\n\n\nPan, L.; Milne, G. A.; Latychev, K.; Goldberg, S. L.; Austermann, J.; Hoggard, M. J. and Mitrovica, J. X. (2022). The influence of lateral Earth structure on inferences of global ice volume during the Last Glacial Maximum. Quaternary Science Reviews 290, 107644. Accessed on Oct 4, 2023.\n\n\n\nPeltier, W. R.; Argus, D. F. and Drummond, R. (2018). Comment on “An Assessment of the ICE‐6G_C (VM5a) Glacial Isostatic Adjustment Model” by Purcell et al. Journal of Geophysical Research: Solid Earth 123, 2019–2028. Accessed on Sep 21, 2023.\n\n\n\nSwierczek-Jereczek, J.; Montoya, M.; Latychev, K.; Robinson, A.; Alvarez-Solas, J. and Mitrovica, J. (2024). FastIsostasy v1. 0–a regional, accelerated 2D glacial isostatic adjustment (GIA) model accounting for the lateral variability of the solid Earth. Geoscientific Model Development 17, 5263–5290.\n\n\n\nWhitehouse, P. L.; Gomez, N.; King, M. A. and Wiens, D. A. (2019). Solid Earth change and the evolution of the Antarctic Ice Sheet. Nature Communications 10, 503. Accessed on Nov 15, 2022.\n\n\n\nWiens, D. A.; Shen, W. and Lloyd, A. J. (2022). The seismic structure of the Antarctic upper mantle. Geological Society, London, Memoirs 56, M56–2020–18. Accessed on Dec 1, 2022.\n\n\n\n","category":"section"},{"location":"API_public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"API_public/#Simulation","page":"Public API","title":"Simulation","text":"","category":"section"},{"location":"API_public/#Computation-domains","page":"Public API","title":"Computation domains","text":"","category":"section"},{"location":"API_public/#Boundary-conditions","page":"Public API","title":"Boundary conditions","text":"","category":"section"},{"location":"API_public/#Ice-thickness","page":"Public API","title":"Ice thickness","text":"","category":"section"},{"location":"API_public/#Boundary-condition-spaces","page":"Public API","title":"Boundary condition spaces","text":"","category":"section"},{"location":"API_public/#Boundary-condition-rules","page":"Public API","title":"Boundary condition rules","text":"","category":"section"},{"location":"API_public/#Sea-level","page":"Public API","title":"Sea level","text":"","category":"section"},{"location":"API_public/#Barystatic-sea-level-(BSL)","page":"Public API","title":"Barystatic sea level (BSL)","text":"","category":"section"},{"location":"API_public/#Sea-surface-(gravitional-response)","page":"Public API","title":"Sea surface (gravitional response)","text":"","category":"section"},{"location":"API_public/#Sea-level-load","page":"Public API","title":"Sea level load","text":"","category":"section"},{"location":"API_public/#Solid-Earth","page":"Public API","title":"Solid Earth","text":"","category":"section"},{"location":"API_public/#Lithosphere","page":"Public API","title":"Lithosphere","text":"","category":"section"},{"location":"API_public/#Mantle","page":"Public API","title":"Mantle","text":"","category":"section"},{"location":"API_public/#Layering","page":"Public API","title":"Layering","text":"","category":"section"},{"location":"API_public/#Calibration","page":"Public API","title":"Calibration","text":"","category":"section"},{"location":"API_public/#Viscosity-lumping","page":"Public API","title":"Viscosity lumping","text":"","category":"section"},{"location":"API_public/#Material-utilities","page":"Public API","title":"Material utilities","text":"","category":"section"},{"location":"API_public/#Input/Output-(I/O)","page":"Public API","title":"Input/Output (I/O)","text":"","category":"section"},{"location":"API_public/#Makie-utilities","page":"Public API","title":"Makie utilities","text":"","category":"section"},{"location":"API_public/#FastIsostasy.Simulation","page":"Public API","title":"FastIsostasy.Simulation","text":"Simulation(domain, c, solidearth, t_out)\nSimulation(domain, c, solidearth, t_out, Hice)\nSimulation(domain, c, solidearth, t_out, t_Hice, Hice)\n\nReturn a struct containing all the other structs needed for the forward integration of the model over domain::RegionalDomain with parameters c::PhysicalConstants and solidearth::SolidEarth. The outputs are stored at t_out::Vector{<:AbstractFloat}. To perform the whole simulation, run!(sim::Simulation) and to perform a single step:\n\ntspan = (t_start, t_end)\nintegrator = init_integrator(sim)\nstep!(integrator, tspan)\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.SolverOptions","page":"Public API","title":"FastIsostasy.SolverOptions","text":"Return a struct containing the options relative to solving a Simulation.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.DiffEqOptions","page":"Public API","title":"FastIsostasy.DiffEqOptions","text":"Contains:\n\nalg::ODEsolvers: the algorithm to integrate the ODE forward in time.\nreltol: the relative error tolerance of the integrator.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.run!","page":"Public API","title":"FastIsostasy.run!","text":"run!(sim::Simulation)\n\n\nSolve the isostatic adjustment problem defined in sim::Simulation.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.init_integrator","page":"Public API","title":"FastIsostasy.init_integrator","text":"init_integrator(sim::Simulation) -> Any\n\n\nInitialise the integrator of sim::Simulation, which can be subsequently integrated forward in time by using step!.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.PhysicalConstants","page":"Public API","title":"FastIsostasy.PhysicalConstants","text":"Return a struct containing important physical constants. Comes with default values that can however be changed by the user, for instance by running:\n\nc = PhysicalConstants(rho_ice = 0.93)   # (kg/m^3)\n\nAll constants are given in SI units (kilogram, meter, second).\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.AbstractDomain","page":"Public API","title":"FastIsostasy.AbstractDomain","text":"Abstract type for domain representation in the model.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.RegionalDomain","page":"Public API","title":"FastIsostasy.RegionalDomain","text":"RegionalDomain\nRegionalDomain(W, n)\nRegionalDomain(Wx, Wy, nx, ny)\n\nReturn a struct containing all information related to geometry of the domain and potentially used parallelism. To initialize one with 2*W and 2^n grid cells:\n\ndomain = RegionalDomain(W, n)\n\nIf a rectangular domain is needed, run:\n\ndomain = RegionalDomain(Wx, Wy, nx, ny)\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.GlobalDomain","page":"Public API","title":"FastIsostasy.GlobalDomain","text":"Not implemented yet!\n\nVersion 3.0 will allow for global domains.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.BoundaryConditions","page":"Public API","title":"FastIsostasy.BoundaryConditions","text":"A struct containing the boundary conditions of the problem:\n\nice_thickness: an instance of AbstractIceThickness that defines how the ice thickness is updated.\nviscous_displacement: a boundary condition for the viscous displacement, defined as an OffsetBC.\nelastic_displacement: a boundary condition for the elastic displacement, defined as an OffsetBC.\nsea_surface_perturbation: a boundary condition for the sea surface perturbation, defined as an OffsetBC.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.apply_bc!","page":"Public API","title":"FastIsostasy.apply_bc!","text":"apply_bc!(H, t, it::TimeInterpolatedIceThickness)\n\n\nUpdate the ice thickness H at time t using the method defined in it.\n\n\n\n\n\napply_bc!(X, bc::OffsetBC)\n\nApply the boundary condition bc to the matrix X in-place.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractIceThickness","page":"Public API","title":"FastIsostasy.AbstractIceThickness","text":"An abstract type that determines how the ice thickness is updated in the model. This is done by implementing the update_ice! function for different subtypes. Available subtypes are:\n\nTimeInterpolatedIceThickness\nExternallyUpdatedIceThickness\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.TimeInterpolatedIceThickness","page":"Public API","title":"FastIsostasy.TimeInterpolatedIceThickness","text":"A struct to update the ice thickness based on time interpolation. Contains:\n\nt_vec: a vector of time points at which the ice thickness is defined.\nH_vec: a vector of ice thickness values corresponding to t_vec.\nH_itp: a function that interpolates the ice thickness based on time.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ExternallyUpdatedIceThickness","page":"Public API","title":"FastIsostasy.ExternallyUpdatedIceThickness","text":"ExternallyUpdatedIceThickness\n\nA struct to indicate that the ice thickness is updated externally, without any internal update.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.AbstractBCSpace","page":"Public API","title":"FastIsostasy.AbstractBCSpace","text":"An abstract type representing the space in which boundary conditions are defined. This typically needs to be defined when initializing an AbstractBCSpace. Available subtypes are:\n\nRegularBCSpace\nExtendedBCSpace\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.RegularBCSpace","page":"Public API","title":"FastIsostasy.RegularBCSpace","text":"Singleton struct to impose boundary conditions at the edges of the computation domain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ExtendedBCSpace","page":"Public API","title":"FastIsostasy.ExtendedBCSpace","text":"Singleton struct to impose boundary conditions at the edges of the extended computation domain, which naturally arises from convolutions.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.AbstractBC","page":"Public API","title":"FastIsostasy.AbstractBC","text":"An abstract type representing a boundary condition in the context of a computational domain. Available subtypes are:\n\nOffsetBC\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.OffsetBC","page":"Public API","title":"FastIsostasy.OffsetBC","text":"A boundary condition that applies an offset to the values at the boundaries of a computational domain. Contains:\n\nspace: the AbstractBCSpace in which the boundary condition is defined.\nx_border: the offset value to be applied at the boundaries.\nW: a weight matrix to apply the boundary condition according to some AbstractBCRule.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.NoBC","page":"Public API","title":"FastIsostasy.NoBC","text":"A singleton struct representing the absence of a boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.CornerBC","page":"Public API","title":"FastIsostasy.CornerBC","text":"Impose a Dirichlet-like boundary condition at the corners of the computational domain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.BorderBC","page":"Public API","title":"FastIsostasy.BorderBC","text":"Impose a Dirichlet-like boundary condition at the borders of the computational domain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.DistanceWeightedBC","page":"Public API","title":"FastIsostasy.DistanceWeightedBC","text":"Impose a Dirichlet-like boundary condition at the borders of the computational domain, weighted by the distance from the center of the domain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.MeanBC","page":"Public API","title":"FastIsostasy.MeanBC","text":"Impose a mean value for the field.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.RegionalSeaLevel","page":"Public API","title":"FastIsostasy.RegionalSeaLevel","text":"A struct that gathers the modelling choices for the sea-level component of the simulation. It contains:\n\nsurface: an instance of AbstractSeaSurface to represent the sea surface.\nload: an instance of AbstractSealevelLoad to represent the sea-level load.\nbsl: an instance of AbstractBSL to represent the barystatic sea level.\nupdate_bsl: an instance of AbstractBSLUpdate to represent the update mechanism for the barystatic sea level.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.AbstractBSL","page":"Public API","title":"FastIsostasy.AbstractBSL","text":"Abstract type to compute the evolution of the barystatic sea level. Available subtypes are:\n\nConstantBSL\nConstantOceanSurfaceBSL\nPiecewiseConstantBSL\nPiecewiseLinearOceanSurfaceBSL (requires using NLsolve)\nImposedBSL\nCombinedBSL\n\nAll subtypes implement the update_bsl! function:\n\nT, delta_V, t = Float64, 1.0e9, 0.0             # Example values\nbsl = PiecewiseConstantBSL()        # or any other subtype!\nupdate_bsl!(bsl, delta_V, t)\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ReferenceBSL","page":"Public API","title":"FastIsostasy.ReferenceBSL","text":"ReferenceBSL(z = 0; T = Float32, itp_kwargs = (extrapolation_bc = Flat()))\n\nA struct used in all subtypes of AbstractBSL to define a reference of barystatic sea level and ocean surface area. Contains:\n\nz: the reference BSL (m), which defaults to 0 (reference year 2020).\nA: the reference ocean surface area (m^2) computed based on z.\nz_vec: a vector of BSL values (m) used for interpolation.\nA_vec: a vector of ocean surface area values (m^2) used for interpolation.\nA_itp: an interpolator function for ocean surface area over BSL.\n\nIn the constructor, T determines the floating point arithmetic used in all computations, and itp_kwargs allows customization of the interpolation.\n\nExample usage:\n\nref = ReferenceBSL()              # assume BSL = 0\n\nCustom:\n\nref = ReferenceBSL(z = 0.1)       # assume BSL = 0.1 m and compute A accordingly\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ConstantBSL","page":"Public API","title":"FastIsostasy.ConstantBSL","text":"A mutable struct containing:\n\nref: an instance of ReferenceBSL.\nz: the BSL, considered constant in time.\nA: the ocean surface area, considered constant in time.\n\nAssume that the BSL is constant in time.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ConstantOceanSurfaceBSL","page":"Public API","title":"FastIsostasy.ConstantOceanSurfaceBSL","text":"A mutable struct containing:\n\nref: an instance of ReferenceBSL.\nz: the BSL at current time step.\nA: the ocean surface area, considered constant in time.\n\nAssume that the ocean surface is constant in time and that the BSL evolves only according to the changes in ice volume covered by the RegionalDomain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.PiecewiseConstantBSL","page":"Public API","title":"FastIsostasy.PiecewiseConstantBSL","text":"A mutable struct containing:\n\nref: an instance of ReferenceBSL.\nz: the BSL at current time step.\nA: the ocean surface at current time step.\n\nAssume that the ocean surface evolves in time according to a piecewise constant function of the BSL, which evolves in time according to the changes in ice volume covered by the RegionalDomain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ImposedBSL","page":"Public API","title":"FastIsostasy.ImposedBSL","text":"A mutable struct containing:\n\nref: an instance of ReferenceBSL.\nz: the BSL at current time step.\nt_vec: the time vector.\nz_vec: the BSL values corresponding to the time vector.\nz_itp: an interpolation of z_vec over t_vec.\n\nImpose an externally computed BSL, which is internally computed via a time interpolation.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.CombinedBSL","page":"Public API","title":"FastIsostasy.CombinedBSL","text":"A mutable structcontaining:\n\nbsl1: an ImposedBSL.\nbsl2: an AbstractBSL.\n\nThis imposes a mixture of BSL. For instance, if you simulate Antarctica over the LGM, you can impose an offline BSL contribution from the other ice sheets via bsl1. The contribution of Antarctica will be intercatively added to this via bsl2.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.AbstractBSLUpdate","page":"Public API","title":"FastIsostasy.AbstractBSLUpdate","text":"An abstract type to determine how the barystatic sea level (BSL) is updated over time. Available subtypes are:\n\nInternalBSLUpdate\nExternalBSLUpdate\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.InternalBSLUpdate","page":"Public API","title":"FastIsostasy.InternalBSLUpdate","text":"A struct to indicate that the BSL is updated internally by the model based on the change in ice volume.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ExternalBSLUpdate","page":"Public API","title":"FastIsostasy.ExternalBSLUpdate","text":"A struct to indicate that the BSL is updated externally, without any internal update.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.update_bsl!","page":"Public API","title":"FastIsostasy.update_bsl!","text":"update_bsl!(bsl::ConstantBSL, delta_V, t)\n\n\nUpdate the BSL and ocean surface based on the input delta_V (in m^3) and on a subtype of AbstractBSL.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractSeaSurface","page":"Public API","title":"FastIsostasy.AbstractSeaSurface","text":"Abstract type for sea surface representation. Available subtypes are:\n\nLaterallyConstantSeaSurface\nLaterallyVariableSeaSurface\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.LaterallyConstantSeaSurface","page":"Public API","title":"FastIsostasy.LaterallyConstantSeaSurface","text":"Assume a laterally constant sea surface across the domain. This means that the gravitatiional response is ignored.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.LaterallyVariableSeaSurface","page":"Public API","title":"FastIsostasy.LaterallyVariableSeaSurface","text":"Assume a laterally variable sea surface across the domain. This means that the gravitational response is included in the sea surface perturbation.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.update_dz_ss!","page":"Public API","title":"FastIsostasy.update_dz_ss!","text":"update_dz_ss!(\n    sim::Simulation,\n    sl::LaterallyVariableSeaSurface\n)\n\n\nUpdate the SSH perturbation dz_ss by convoluting the Green's function with the load anom.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractSealevelLoad","page":"Public API","title":"FastIsostasy.AbstractSealevelLoad","text":"Abstract type for sea-level load representation. Available subtypes are:\n\nNoSealevelLoad\nInteractiveSealevelLoad\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.NoSealevelLoad","page":"Public API","title":"FastIsostasy.NoSealevelLoad","text":"Assume no sea-level load, i.e. the bedrock deformation is not influenced by the sea-level.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.InteractiveSealevelLoad","page":"Public API","title":"FastIsostasy.InteractiveSealevelLoad","text":"Assume an interactive sea-level load, i.e. the bedrock deformation is influenced by the sea-level.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.columnanom_water!","page":"Public API","title":"FastIsostasy.columnanom_water!","text":"columnanom_water!(\n    sim::Simulation,\n    ol::InteractiveSealevelLoad\n)\n\n\nUpdate the water column based on the instance of AbstractSealevelLoad.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.SolidEarth","page":"Public API","title":"FastIsostasy.SolidEarth","text":"Return a struct containing all information related to the lateral variability of solid-Earth parameters. To initialize with values other than default, run:\n\ndomain = RegionalDomain(3000e3, 7)\nlb = [100e3, 300e3]\nlv = [1e19, 1e21]\nsolidearth = SolidEarth(domain, layer_boundaries = lb, layer_viscosities = lv)\n\nwhich initializes a lithosphere of thickness T_1 = 100 mathrmkm, a viscous channel between T_1and T_2 = 300 mathrmkmand a viscous halfspace starting at T_2. This represents a homogenous case. For heterogeneous ones, simply make lb::Vector{Matrix}, lv::Vector{Matrix} such that the vector elements represent the lateral variability of each layer on the grid of domain::RegionalDomain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.AbstractLithosphere","page":"Public API","title":"FastIsostasy.AbstractLithosphere","text":"Available subtypes are:\n\nRigidLithosphere\nLaterallyConstantLithosphere\nLaterallyVariableLithosphere\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.RigidLithosphere","page":"Public API","title":"FastIsostasy.RigidLithosphere","text":"Assume a rigid lithosphere, i.e. the elastic deformation is neglected.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.LaterallyConstantLithosphere","page":"Public API","title":"FastIsostasy.LaterallyConstantLithosphere","text":"Assume a laterally constant lithospheric thickness (and rigidity) across the domain. This generally improves the performance of the solver, but is less realistic.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.LaterallyVariableLithosphere","page":"Public API","title":"FastIsostasy.LaterallyVariableLithosphere","text":"Assume a laterally variable lithospheric thickness (and rigidity) across the domain. This generally improves the realism of the model, but is more computationally expensive.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.update_elasticresponse!","page":"Public API","title":"FastIsostasy.update_elasticresponse!","text":"update_elasticresponse!(\n    sim::Simulation,\n    lithosphere::AbstractLithosphere\n)\n\n\nUpdate the elastic response by convoluting the Green's function with the load anom. To use coefficients differing from [Farrell1972], see GIATools.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractMantle","page":"Public API","title":"FastIsostasy.AbstractMantle","text":"Available subtypes are:\n\nRigidMantle\nRelaxedMantle\nMaxwellMantle\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.RigidMantle","page":"Public API","title":"FastIsostasy.RigidMantle","text":"Assume a rigid mantle that does not deform.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.RelaxedMantle","page":"Public API","title":"FastIsostasy.RelaxedMantle","text":"Assume a relaxed mantle that deforms according to a relaxation time. This is generally less realistic and offers worse performance than a viscous mantle. It is only included for legacy purpose (e.g. comparison among solvers).\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.MaxwellMantle","page":"Public API","title":"FastIsostasy.MaxwellMantle","text":"Assume a viscous mantle that deforms according to a viscosity. This is the most realistic mantle model and generally offers the best performance. It is the default mantle model used in the solver.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.update_dudt!","page":"Public API","title":"FastIsostasy.update_dudt!","text":"update_dudt!(dudt, u, sim, t, earth::SolidEarth) -> Any\n\n\nUpdate the time derivative of the viscous displacement dudt based on an AbstractMantle:\n\nRigidMantle: no deformation, dudt is zero.\nRelaxedMantle with LaterallyConstantLithosphere: uses ELRA (LeMeur & Huybrechts 1996) to compute the viscous response. This also works with laterally-variable relaxation time, as proposed in Van Calcar et al., in rev.\nRelaxedMantle with LaterallyVariableLithosphere: not implemented. This corresponds to what is described in Coulon et al. (2021) but is not yet implemented.\nMaxwellMantle with LaterallyConstantLithosphere or RigidLithosphere: not implemented. This corresponds to what is described in Bueler et al. (2007) but is not yet implemented.\nMaxwellMantle with LaterallyVariableLithosphere: This corresponds to the approach of Swierczek-Jereczek et al. (2024).\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractLayering","page":"Public API","title":"FastIsostasy.AbstractLayering","text":"Abstract type for layering models. Subtypes should implement the layer_boundaries function. Available subtypes are:\n\nUniformLayering\nParallelLayering\nEqualizedLayering\nFoldedLayering\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.UniformLayering","page":"Public API","title":"FastIsostasy.UniformLayering","text":"Struct to enforce uniform layering when passed to get_layer_boundaries. Contains:\n\nn_layers: the number of layers in the model.\nboundaries: the layer boundaries, which are constant across the domain.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.ParallelLayering","page":"Public API","title":"FastIsostasy.ParallelLayering","text":"Struct to enforce parallel layering when passed to get_layer_boundaries. Contains:\n\nn_layers: the number of layers in the model.\nthickness: the thickness of each layer.\ntol: a tolerance value to add to the layer boundaries.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.EqualizedLayering","page":"Public API","title":"FastIsostasy.EqualizedLayering","text":"Struct to enforce equalized layering when passed to get_layer_boundaries. Contains:\n\nn_layers: the number of layers in the model.\nboundaries: the layer boundaries.\ntol: a tolerance value to add to the layer boundaries.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.FoldedLayering","page":"Public API","title":"FastIsostasy.FoldedLayering","text":"Struct to enforce folded layering when passed to get_layer_boundaries. Contains:\n\nn_layers: the number of layers in the model.\nmax_depth: the maximum depth of the layers.\ntol: a tolerance value to add to the layer boundaries.\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.get_layer_boundaries","page":"Public API","title":"FastIsostasy.get_layer_boundaries","text":"get_layer_boundaries(\n    domain::RegionalDomain,\n    litho_thickness,\n    layering\n) -> Any\n\n\nCompute the layer boundaries for a given AbstractLayering. Output is typically passed to SolidEarth to create a layered Earth model.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractCalibration","page":"Public API","title":"FastIsostasy.AbstractCalibration","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.NoCalibration","page":"Public API","title":"FastIsostasy.NoCalibration","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.SeakonCalibration","page":"Public API","title":"FastIsostasy.SeakonCalibration","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.apply_calibration!","page":"Public API","title":"FastIsostasy.apply_calibration!","text":"apply_calibration!(eta, calibraton::NoCalibration) -> Any\n\n\nApply the calibration to the viscosity eta.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.AbstractViscosityLumping","page":"Public API","title":"FastIsostasy.AbstractViscosityLumping","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.TimeDomainViscosityLumping","page":"Public API","title":"FastIsostasy.TimeDomainViscosityLumping","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.FreqDomainViscosityLumping","page":"Public API","title":"FastIsostasy.FreqDomainViscosityLumping","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.MeanViscosityLumping","page":"Public API","title":"FastIsostasy.MeanViscosityLumping","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.MeanLogViscosityLumping","page":"Public API","title":"FastIsostasy.MeanLogViscosityLumping","text":"\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.get_effective_viscosity_and_scaling","page":"Public API","title":"FastIsostasy.get_effective_viscosity_and_scaling","text":"get_effective_viscosity_and_scaling(\n    domain,\n    layer_viscosities,\n    layer_boundaries,\n    maskactive,\n    lumping::TimeDomainViscosityLumping\n) -> Tuple{Any, Any}\n\n\nCompute equivalent viscosity for multilayer model by recursively applying the formula for a halfspace and a channel from Lingle and Clark (1975).\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_rigidity","page":"Public API","title":"FastIsostasy.get_rigidity","text":"get_rigidity(t, E, nu) -> Any\n\n\nCompute rigidity D based on thickness t, Young modulus E and Poisson ration nu.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_shearmodulus","page":"Public API","title":"FastIsostasy.get_shearmodulus","text":"get_shearmodulus(youngmodulus, poissonratio) -> Any\n\n\nCompute shear modulus G based on Young modulus E and Poisson ratio nu, or based on seismic velocities.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_elastic_green","page":"Public API","title":"FastIsostasy.get_elastic_green","text":"get_elastic_green(\n    domain::RegionalDomain,\n    greenintegrand_function,\n    quad_support,\n    quad_coeffs\n) -> Matrix{T} where T<:AbstractFloat\n\n\nIntegrate load response over field by using 2D quadrature with specified support points and associated coefficients.\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_flexural_lengthscale","page":"Public API","title":"FastIsostasy.get_flexural_lengthscale","text":"get_flexural_lengthscale(\n    litho_rigidity,\n    rho_uppermantle,\n    g\n) -> Any\n\n\nCompute the flexural length scale, based on Coulon et al. (2021), Eq. in text after Eq. 3. The flexural length scale will be on the order of 100km.\n\nArguments\n\nlitho_rigidity: Lithospheric rigidity\nrho_uppermantle: Density of the upper mantle\ng: Gravitational acceleration\n\nReturns\n\nL_w: The calculated flexural length scale\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_relaxation_time","page":"Public API","title":"FastIsostasy.get_relaxation_time","text":"get_relaxation_time(eta, m, p) -> Any\n\n\nConvert the viscosity to relaxation times following Van Calcar et al. (in rev.).\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_relaxation_time_weaker","page":"Public API","title":"FastIsostasy.get_relaxation_time_weaker","text":"get_relaxation_time_weaker(eta) -> Any\n\n\nCompute the relaxation time for a weaker mantle, following Van Calcar et al. (in rev.).\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.get_relaxation_time_stronger","page":"Public API","title":"FastIsostasy.get_relaxation_time_stronger","text":"get_relaxation_time_stronger(eta) -> Any\n\n\nCompute the relaxation time for a stronger mantle, following Van Calcar et al. (in rev.).\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.load_dataset","page":"Public API","title":"FastIsostasy.load_dataset","text":"load_dataset(\n    name::String;\n    kwargs...\n) -> Union{Nothing, Tuple{Any, Any, Any}}\n\n\nReturn the dims::Tuple{Vararg{Vector}}, the field<:Array and the interpolator corresponding to a data set defined by a unique name::String. For instance:\n\n(lon180, lat, t), Hice, Hice_itp = load_dataset(\"ICE6G_D\")\n\nFollowing options are available for parameter fields:\n\n\"ICE6GD\": ice loading history from ICE6GD.\n\"Wiens2022\": viscosity field from (Wiens et al. 2022)\n\"Lithothickness_Pan2022\": lithospheric thickness field from (Pan et al. 2022)\n\"Viscosity_Pan2022\": viscosity field from (Pan et al. 2022)\n\nFollowing options are available for model results:\n\n\"Spada2011\"\n\"LatychevGaussian\"\n\"LatychevICE6G\"\n\n\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.NetcdfOutput","page":"Public API","title":"FastIsostasy.NetcdfOutput","text":"A struct that contains all the necessary information to store the output in a NetCDF file.\n\nCan be initilized as:\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.NativeOutput","page":"Public API","title":"FastIsostasy.NativeOutput","text":"Return a mutable struct containing the native output which will be updated over the simulation.\n\nInitialization example:\n\nnout = NativeOutput(vars = [:u, :ue, :b, :dz_ss, :H_ice, :H_water, :u_x, :u_y],\n    t = collect(0:1f3:10f3))\n\n\n\n\n\n","category":"type"},{"location":"API_public/#FastIsostasy.plot_transect","page":"Public API","title":"FastIsostasy.plot_transect","text":"\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.plot_load","page":"Public API","title":"FastIsostasy.plot_load","text":"\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.plot_earth","page":"Public API","title":"FastIsostasy.plot_earth","text":"\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.plot_out_at_time","page":"Public API","title":"FastIsostasy.plot_out_at_time","text":"\n\n\n\n","category":"function"},{"location":"API_public/#FastIsostasy.plot_out_over_time","page":"Public API","title":"FastIsostasy.plot_out_over_time","text":"\n\n\n\n","category":"function"},{"location":"examples/benchmark_1D/#1D-GIA-benchmark","page":"1D GIA benchmark","title":"1D GIA benchmark","text":"To make things a bit more interesting, we now propose to reproduce one of experiments proposed in a benchmark study of 1D GIA models (Spada et al. 2011). Test 1/2 (Fig. 9 and 10) consists of a 1D ice cap with a maximum thickness of 1500 m and a maximum latitude of 10° (i.e. the ice cap has a radius of about 1000 km wide). The lithosphere is assumed to be 100 km thick and the mantle is assumed to be layered, with a viscosity of 1e21 Pa s in the upper mantle and 2e21 Pa s in the lower mantle. The lithosphere is assumed to be elastic, with a Young's modulus of 70 GPa and a Poisson's ratio of 0.28. The ice load is applied at time t = 0 and kept constant until t = 100 kyr. The gravitational response and the resulting change in sea-surface elevation is computed, however without affecting the load that is applied to the solid Earth.\n\nNote that Spada et al. (2011) use parameters that differ from FastIsostasy's default and that are passed to the simulation via PhysicalConstants and SolidEarth.\n\nusing FastIsostasy, CairoMakie\n\nW, n, T = 3f6, 7, Float32\ndomain = RegionalDomain(W, n)\nc = PhysicalConstants{T}(rho_ice = 0.931e3)\n\nH_ice_0 = zeros(domain)     # Load: 0 at the beginning\nalpha = T(10)               # Load: cap with max colatitude 10°...\nHmax = T(1500)              # ... and thickness 1500 m afterwards\nH_ice_1 = stereo_ice_cap(domain, alpha, Hmax)\nfig = plot_load(domain, H_ice_1)\n\nThis already looks a bit more like a real ice sheet! Again, let's wrap this into an interpolator passed to a BoundaryConditions instance. The current example is of interest because 1D GIA models include the elastic and the gravitational response to changes in the surface load. The former is included by default in SolidEarth (unless specified, as done in the previous example) and the latter can be specified in the RegionalSeaLevel instance:\n\nt_ice = [-1f-3, 0, 100f3]\nH_ice = [H_ice_0, H_ice_1, H_ice_1]\nit = TimeInterpolatedIceThickness(t_ice, H_ice, domain)     # Wrap in time interpolator\nbcs = BoundaryConditions(domain, ice_thickness = it)        # Pass to boundary conditions\n\nsealevel = RegionalSeaLevel(surface = LaterallyVariableSeaSurface())    # gravitational response: on\n\nG = 0.50605f11              # Shear modulus (Pa)\nnu = 0.28f0                 # Poisson ratio\nE = G * 2 * (1 + nu)        # Young modulus\nlb = c.r_equator .- [6301f3, 5951f3, 5701f3]    # 3 layer boundaries\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = T.(lb),\n    layer_viscosities = [1f21, 1f21, 2f21],\n    litho_youngmodulus = E,\n    litho_poissonratio = nu,\n    rho_litho = 3100f0,\n    rho_uppermantle = 3500f0,\n)\n\n\nnout = NativeOutput(vars = [:u, :ue, :dz_ss],               # Define the fields to be saved...\n    t = [0, 10, 1_000, 2_000, 5_000, 10_000, 100_000f0])    # And the time steps!\nsim = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim)\nfig = plot_transect(sim, [:ue, :u, :dz_ss])\n\nBy comparing these results to Fig. 9 of Spada et al. (2011), we can see that the deformational and gravitational response obtained by FastIsostasy are very similar to that obtained by 1D GIA models. Let's see how much time was required for this:\n\nprintln(\"Computation time (s): $(sim.nout.computation_time)\")\n\nThis is at least 2 orders of magnitude faster than typical 1D GIA models, without any major loss in accuracy!","category":"section"},{"location":"examples/benchmark_1D/#Bonus","page":"1D GIA benchmark","title":"Bonus","text":"Swierczek-Jereczek et al. (2024) provides a comparison between FastIsostasy and a 3D GIA model, while assuming a 1D Earth structure. The first case assumes a layered Earth corresponding to the preliminary reference Earth model (PREM, ???) and can be reproduced as follows:\n\nH_ice_0 = zeros(domain)             # Load: 0 at the beginning...\nH_ice_1 = 1f3 .* (domain.R .< 1f6)  # cylinder afterwards\nt_ice = [0, 1, 50f3]\nH_ice = [H_ice_0, H_ice_1, H_ice_1]\nit = TimeInterpolatedIceThickness(t_ice, H_ice, domain)\nbcs = BoundaryConditions(domain, ice_thickness = it)\n\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = [100f3, 670f3],\n    layer_viscosities = [0.5f21, 5f21],\n    rho_uppermantle = 3.6f3,\n    lumping = FreqDomainViscosityLumping(),\n)\n\nnout = NativeOutput(vars = [:u, :ue],                               # Define the fields to be saved...\n    t = [0, 1f3, 2f3, 3f3, 4f3, 5f3, 10f3, 20f3, 30f3, 40f3, 50f3]) # And the time steps!\nsim1 = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim1)\nfig = plot_transect(sim1, [:ue, :u])\n\nThe second case assumes the absence of lithosphere and a homogeneous mantle with a viscosity of 1e21 Pa s:\n\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = [1f0, 150f3],\n    layer_viscosities = [1f21, 1f21],\n    rho_uppermantle = 3.6f3,\n)\nnout = NativeOutput(vars = [:u, :ue],                               # Define the fields to be saved...\n    t = [0, 1f3, 2f3, 3f3, 4f3, 5f3, 10f3, 20f3, 30f3, 40f3, 50f3]) # And the time steps!\nsim2 = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim2)\nfig = plot_transect(sim2, [:ue, :u])\n\nFinally, we can check the computation times:\n\nprintln(\"Computation time (s): $(sim1.nout.computation_time)\")\nprintln(\"Computation time (s): $(sim2.nout.computation_time)\")","category":"section"},{"location":"models/","page":"-","title":"-","text":"GIA typically consist of a gravitational, a rotational and a deformational response, which motivates the use of GRD as a commonly used alternative accronym. FastIsostasy ignores the rotational response but approximates the gravitational one. The deformational response can be represented by a wide variety of models. The most sophisticated one is able to represent the laterally-variable mantle viscosity and lithospheric thickness. It is described in Swierczek-Jereczek et al. (2024) and is mainly adressed to ice-sheet modellers who seek for a good representation of solid-Earth mechanics at virtually zero computational cost. The simple interface of FastIsostasy allows to flexibly solve GIA problems within a few lines of code. The code is distributed under GNU general public license v3 and was succesfully benchmarked against analytical, 1D GIA and 3D GIA model solutions.\n\nBased on the work of Cathles (1975) and Lingle and Clark (1985), an efficient way of solving for the vertical displacement was proposed by Bueler et al. (2007). FastIsostasy generalises this approach by relying on a hybrid Fourier/finite-difference collocation. Thanks to a simplification of the full problem from 3D to 2D space and the use of optimized software packages, running kiloyears of regional GIA with Delta x = Delta y = 45  mathrmkm is a matter of seconds on a single CPU. For high resolution runs, the user can switch to GPU usage with minimal syntax change and enjoy the advantage of parallelization without requiring an HPC cluster. For GIA \"purists\", this package is likely to miss interesting processes but we belive that its ridiculous run-time can help to fast-prototype a problem before transfering it to a more comprehensive model.","category":"section"},{"location":"examples/benchmark_3D/#3D-GIA-benchmark","page":"3D GIA benchmark","title":"3D GIA benchmark","text":"After comparing our results against analytical and 1D numerical solution, the obvious next step is to compare our results against 3D numerical solutions, where the lithospheric thickness and the mantle viscosity vary in x and y. We reproduce Test 3 from Swierczek-Jereczek et al. (2024), where a 1D Earth structure is perturbed by a Gaussian field in 4 different ways:\n\nA reduction of the lithospheric thickness from 150 km (at margin of the domain) to 50 km (at the center of the domain).\nAn increase of the lithospheric thickness from 150 km (at margin of the domain) to 250 km (at the center of the domain).\nA reduction of the mantle viscosity from 10^21 Pa s (at margin of the domain) to 10^20 Pa s (at the center of the domain).\nAn increase of the mantle viscosity from 10^21 Pa s (at margin of the domain) to 10^22 Pa s (at the center of the domain).\n\nThe ice load used as a forcing is the same as in the analytical example and the sea level computation is turned off to isolate the effect of a 3D Earth structure on the deformational response.","category":"section"},{"location":"examples/benchmark_3D/#Case-1:-Reduction-of-lithospheric-thickness","page":"3D GIA benchmark","title":"Case 1: Reduction of lithospheric thickness","text":"using FastIsostasy, CairoMakie, LinearAlgebra\n\nW, n = 3f6, 7\ndomain = RegionalDomain(W, n)\nH_ice_0 = zeros(domain)\nH_ice_1 = 1f3 .* (domain.R .< 1f6)\nt_ice = [0, 1f-8, 50f3]\nH_ice = [H_ice_0, H_ice_1, H_ice_1]\nit = TimeInterpolatedIceThickness(t_ice, H_ice, domain)\nbcs = BoundaryConditions(domain, ice_thickness = it)\nsealevel = RegionalSeaLevel()\n\nsigma = diagm([(W/4)^2, (W/4)^2])\nthinning_lithosphere = generate_gaussian_field(domain, 150f3, [0f0, 0], -100f3, sigma)\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = thinning_lithosphere,\n    layer_viscosities = [1f21],\n)\nfig = plot_earth(domain, solidearth)\n\nNow let's see what result we obtain:\n\nnout = NativeOutput(vars = [:u, :ue], t = vcat(0, 1f3:1f3:4f3, 5f3, 10f3:10f3:50f3))\nsim1 = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim1)\nfig = plot_transect(sim1, [:u, :ue])\n\nThis is very similar to the result obtained by Seakon (3D GIA model) as presented in Swierczek-Jereczek et al. (2024, Fig. 8.a)! Let's dig into the other cases:","category":"section"},{"location":"examples/benchmark_3D/#Case-2:-Increase-of-lithospheric-thickness","page":"3D GIA benchmark","title":"Case 2: Increase of lithospheric thickness","text":"thickenning_lithosphere = generate_gaussian_field(domain, 150f3, [0f0, 0], 100f3, sigma)\n\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = thickenning_lithosphere,\n    layer_viscosities = [1f21],\n)\nfig = plot_earth(domain, solidearth)\n\nWhich is basically the opposite of Case 1!\n\nNow let's see what result we obtain:\n\nsim2 = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\n\nrun!(sim2)\nfig = plot_transect(sim2, [:u, :ue])\n\nIt looks like a thicker lithosphere prevents flexure! This tends to \"spread\" the deformation by creating a higher lateral coupling between neighbouring cells. In comparison, a thin lithosphere makes the displacement more localized, as the flexural rigidity is lower and the cells are more decoupled from each other.\n\nComparing these results to those of Seakon gives a good match (Swierczek-Jereczek et al., 2024, Fig. 8.b). Now let's dive into cases of laterally-varying mantle viscosities.","category":"section"},{"location":"examples/benchmark_3D/#Case-3:-Reduction-of-mantle-viscosity","page":"3D GIA benchmark","title":"Case 3: Reduction of mantle viscosity","text":"log10visc = generate_gaussian_field(domain, 21f0, [0f0, 0], -1f0, sigma)\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = [150f3],\n    layer_viscosities = reshape(10 .^ log10visc, domain.nx, domain.ny, 1),\n    calibration = SeakonCalibration(),\n)\nfig = plot_earth(domain, solidearth)\n\nHere we used SeakonCalibration as calibration passed to SolidEarth. As described in Appendix C of Swierczek-Jereczek et al. (2024), this allows to include the effect of a laterally varying shear modulus on the effective viscosity, which yields about 1f20.5 instead of the expected 1f20.\n\nsim3 = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim3)\nfig = plot_transect(sim3, [:u, :ue])\n\nAs expected, the displacement takes place much faster than in the previous cases. Comparing these results to those of Seakon gives a good match (Swierczek-Jereczek et al., 2024, Fig. 8.c).","category":"section"},{"location":"examples/benchmark_3D/#Case-4:-Increase-of-mantle-viscosity","page":"3D GIA benchmark","title":"Case 4: Increase of mantle viscosity","text":"We now perform the opposite viscosity perturbation to Case 3:\n\nlog10visc = generate_gaussian_field(domain, 21f0, [0f0, 0], 1f0, sigma)\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = [150f3],\n    layer_viscosities = reshape(10 .^ log10visc, domain.nx, domain.ny, 1),\n    calibration = SeakonCalibration(),\n)\nfig = plot_earth(domain, solidearth)\n\nDue to the applied calibration, the effective viscosity yields about 1f21.5 instead of the expected 1f22. This means that the calibration tends to reduce the difference between the viscosity and the reference one, set in SeakonCalibration.\n\nsim4 = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim4)\nfig = plot_transect(sim4, [:u, :ue])\n\nAs expected, the displacement takes place much slower than in the previous cases. Comparing these results to those of Seakon gives a good match (Swierczek-Jereczek et al., 2024, Fig. 8.d).\n\nFastIsostasy performs these runs much faster than 3D GIA models (several orders of magnitude). For instance:\n\nfor sim in (sim1, sim2, sim3, sim4)\n    println(\"Computation time (s): $(sim.nout.computation_time)\")\nend","category":"section"},{"location":"examples/benchmark_analytic/#Analytical-benchmark","page":"Analytical benchmark","title":"Analytical benchmark","text":"","category":"section"},{"location":"examples/benchmark_analytic/#Explicit-time-stepping-(recommended)","page":"Analytical benchmark","title":"Explicit time stepping (recommended)","text":"In this example, we want to compute the viscous displacement of the upper mantle resulting from a cylindrical ice load with a radius of 1000 km and a thickness of 1 km. To do so, we first generate the computation domain and the load:\n\nusing FastIsostasy, CairoMakie\n\nW, n = 3f6, 7   # square domain with size 2*W and 2^n points in each dimension\ndomain = RegionalDomain(W, n)\n\nH_ice_0 = zeros(domain)             # Load: 0 at the beginning...\nH_ice_1 = 1f3 .* (domain.R .< 1f6)  # cylinder afterwards\nfig = plot_load(domain, H_ice_1)\n\nThis looks good! plot_load is a function of FastIsostasy that, similar to all functions plot_*, is only loaded if the user is using Makie. These functions are here to help the user visualize quickly the results that were obtained and are summarized in the API reference.\n\nFirst, we wrap the ice load as a time interpolator so that the boundary doncitions of FastIsostasy can be updated internally (if you want to update the ice thickness externally, have a look at this). Then we define a solid earth structure, a sea-level model (that is inactive by default) and an output object. The simulation is subsequently executed with run!(). The Earth structure deserves particular attention, since it determines key properties of the problem. We here define a single layer boundary at 88 km depth. This means that the lithosphere is 88 km thick and the mantle below it is assumed to be a Maxwell body with a viscosity of 1f21 Pa s. The lithosphere density is set to 0, such that its displacement does not contribute to the pressure term of the isostatic adjustment (this is done to match Bueler et al., 2007).\n\nt_ice = [0, 1, 50f3]\nH_ice = [H_ice_0, H_ice_1, H_ice_1]\nit = TimeInterpolatedIceThickness(t_ice, H_ice, domain)\n\nbcs = BoundaryConditions(domain, ice_thickness = it)\n\nsolidearth = SolidEarth(    # Use the same geometry as in Bueler et al. (2007).\n    domain,\n    layer_boundaries = [88f3],\n    layer_viscosities = [1f21],\n    rho_litho = 0f0,\n)\n\nsealevel = RegionalSeaLevel()               # Will be inactive if not specified.\n\nnout = NativeOutput(vars = [:u],    # only store viscous displacement.\n    t = [100, 500, 1500, 5000, 10_000, 50_000f0])\n\nsim = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim)\nfig = plot_transect(sim, [:u])\n\nThe viscous displacement field that we obtained is quite intuitive: its shape is largely determined by the forcing and its maximal amplitude is a fraction of the ice thickness is about \\dfrac{ \\rho\\mathrm{ice} }{ \\rho\\mathrm{mantle} }. This simple example presents the advantage to have an analytical solution, which can be plotted along our solution:\n\nfig = plot_transect(sim, [:u], analytic_cylinder_solution = true)\n\nOur numerical solution yields very small error!\n\nFastIsostasy was designed to be computationally efficient. We are therefore particularly interested in the time needed for the computation, which is stored in the nout object of the simulation.\n\nprintln(\"Computation time using explicit time stepping: $(sim.nout.computation_time)\")\n\nThis is the (compilation + computation) time that was required to compute 50 kyr of viscous displacement with a domain of 128x128 points!","category":"section"},{"location":"examples/benchmark_analytic/#Implicit-time-stepping","page":"Analytical benchmark","title":"Implicit time stepping","text":"If the Earth structure is laterally constant (i.e. the lithospheric thickness and the mantle viscosity do not vary in x and y), the performance can be improved by using an implicit time stepping, as derived by Bueler et al. (2007). This can be achieved by specifying the lithosphere as RigidLithosphere() or as LaterallyConstantLithosphere() and requires to set a fixed time step via the DiffEqOptions in the SolverOptions:\n\nsolidearth = SolidEarth(\n    domain,\n    lithosphere = RigidLithosphere(),\n    layer_boundaries = [88f3],\n    layer_viscosities = [1f21],\n)\nopts = SolverOptions(diffeq = DiffEqOptions(alg = Euler(), dt_min = 100f0))\nsim_implicit = Simulation(domain, bcs, sealevel, solidearth; nout = nout, opts = opts)\nrun!(sim_implicit)\nfig = plot_transect(sim_implicit, [:u], analytic_cylinder_solution = true)\n\nThe results appear to be comparable with the previously obtained ones! However, the computation time is lower:\n\nprintln(\"Computation time using implicit time stepping: $(sim_implicit.nout.computation_time)\")\n\nwarning: Implicit time stepping is very specific\nIf you are not sure whether your Earth structure is laterally constant, you should not use the implicit time stepping. The results will be wrong if the lithosphere thickness or the mantle viscosity vary in x and y.\n\nAll of the computations shown above are performed with Float32 as floating point precision. It is easy to switch to Float64, by passing arguments as such (e.g. W = 3e6). This will increase the accuracy of the results, but also the computation time. The default Float32 is sufficient for most applications.\n\nOf course, this example remains simple. If you want to learn how to increase the complexity of your simulations, go to the next examples!","category":"section"},{"location":"API_private/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"API_private/#FastIsostasy.GIATools","page":"Private API","title":"FastIsostasy.GIATools","text":"Return a struct containing pre-computed tools to perform forward-stepping of the model. This includes the Green's functions for the computation of the lithosphere and the SSH perturbation, plans for FFTs, interpolators of the load and the viscosity over time and preallocated arrays.\n\n\n\n\n\n","category":"type"},{"location":"introGIA/#Quick-intro-to-GIA","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"Glacial isostatic adjustment (GIA) denotes the crustal deformation that results from changes in the ice, liquid water and sediment columns, as well as associated changes in Earth's gravity and rotation axis, ultimately impacting the sea level. The magnitude and time scale of the deformational response depends on the applied load and on solid-Earth parameters, i.e. the mantle viscosity, the lithosphere thickness and their respective density. These parameters display a radial and sometimes also a lateral variability. For further details, please refer to Wiens et al. (2022) and Ivins et al. (2022).","category":"section"},{"location":"introGIA/#Why-do-we-care?","page":"Quick intro to GIA","title":"Why do we care?","text":"GIA is known to present many feedbacks on ice-sheet evolution (Whitehouse et al., 2019). Their net effect is negative, meaning that GIA inhibits ice-sheet growth and retreat. A good representation of GIA is therefore needed to obtain realistic paleoclimatic reconstructions of ice sheets, as well as reliable projections of future sea level rise due to anthropogenic warming. The effect of GIA in this context appears to be particularly relevant as a large portion of human societies are concentrated along coasts.","category":"section"},{"location":"fortran/#Fortran-version","page":"Fortran version","title":"Fortran version","text":"Since Julia does not allow compilation to binaries yet, some researchers might find it hard to couple FastIsostasy.jl to their favourite ice-sheet model. To tackle this, a Fortran version has been developed. It however lacks some features, which are summarised below:\n\nLibrary of time-integration methods reduced to explicit Euler,\nOnly fixed time stepping allowed,\nComputation on GPU not supported.\n\nThese discrepancies are unlikely to be gapped in the future, mostly because the Fortran ecosystem is less extensive than the Julia one.","category":"section"},{"location":"examples/glacialcycle/#Glacial-cycle","page":"Glacial cycle","title":"Glacial cycle","text":"The previous examples focused on benchmarking FastIsostasy against analytical, numerical 1D and numerical 3D solutions. However, these cases were largely idealised. To test the model on more realistic simulations, we now provide compute the GIA response in Antarctica over the last glacial cycle. This includes the use of:\n\na heterogeneous lithosphere thickness (Pan et al., 2022),\na heterogeneous upper-mantle viscosity (Pan et al., 2022),\na stack of few viscous channels,\na more elaborate load that evolves over time (Peltier et al., 2018),\ntransient changes of the relative sea-level.\n\nWe start by generating a RegionalDomain with intermediate resolution for the sake of the example and load the ice history thanks to the convenience of load_dataset. To get an idea of the ICE6G forcing, the ice thickness is visualised at the last glacial maximum (LGM):\n\nusing CairoMakie, FastIsostasy, Statistics\n\nN = 140\ndomain = RegionalDomain(3500e3, 3500e3, N, N)   # resolution = 50 km\nLon, Lat = domain.Lon, domain.Lat\n(_, _, t), Hice, Hitp = load_dataset(\"ICE6G_D\")\nHice_vec = [Hitp.(Lon, Lat, tk) for tk in t]\nk_lgm = argmax([mean(Hice_vec[k]) for k in eachindex(Hice_vec)])\nplot_load(domain, Hice_vec[k_lgm])\n\nThis already looks like a much more exciting ice thickness field! Here again, the ice history is wrapped into an interpolator, which is passed to an instance of BoundaryConditions. We define the RegionalSeaLevel to include the gravitational response by making the surface a LaterallyVariableSeaSurface. Furthermore, we allow the changes in sea level to affect the deformational response of the solid Earth by setting InteractiveSealevelLoad. Finally, we compute the evolution of the barystatic sea level (BSL) according to a piece-wise constant approximation of the ocean surface as a function of the BSL:\n\nit = TimeInterpolatedIceThickness(t .* 1e3, Hice_vec, domain)\nbcs = BoundaryConditions(domain, ice_thickness = it)\nsealevel = RegionalSeaLevel(\n    surface = LaterallyVariableSeaSurface(),\n    load = InteractiveSealevelLoad(),\n    bsl = PiecewiseConstantBSL(),\n)\n\nFinally, we load the interpolators of earth structure thanks to the convenience function load_dataset.\n\n(_, _), Tpan, Titp = load_dataset(\"Lithothickness_Pan2022\")\nTlitho = Titp.(Lon, Lat) .* 1e3                     # convert from km to m\n(_, _, _), _, logeta_itp = load_dataset(\"Viscosity_Pan2022\");\nnothing #hide\n\nThe number of layers and the depth of viscous half-space are arbitrary parameters that have to be defined by the user. We here use a relatively shallow model (half-space begins at 300 km depth) with 1 equalisation layer and 3 intermediate layers.\n\nmindepth = maximum(Tlitho) + 1e3\nlayerboundary_vec = range(mindepth, stop = 300e3, length = 3)\nlb = cat(Tlitho, [fill(lbval, domain.nx, domain.ny)\n    for lbval in layerboundary_vec]..., dims=3)\nrlb = 6371e3 .- lb\nnlb = size(rlb, 3)\nlv_3D = 10 .^ cat([logeta_itp.(Lon, Lat, rlb[:, :, k]) for k in 1:nlb]..., dims=3)\n\neta_lowerbound = 1e16\nlv_3D[lv_3D .< eta_lowerbound] .= eta_lowerbound\nmaskactive = gaussian_smooth(Hice_vec[k_lgm], domain, 0.05, 0) .> 10\nsolidearth = SolidEarth(\n    domain,\n    layer_boundaries = lb,\n    layer_viscosities = lv_3D,\n    maskactive = maskactive,    # required when using `InteractiveSealevelLoad`\n)\nfig = plot_earth(domain, solidearth)\n\nThis already looks like a much more exciting solid Earth structure!\n\nFinally, we define the output struct, the Simulation and run! it.\n\nnout = NativeOutput(vars = [:u, :ue, :dz_ss, :z_ss, :H_ice], t = [-26f3, -12f3, 0])\nsim = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim)\nprintln(\"Computation time: \", sim.nout.computation_time)\n\nOk, that was fast! Let's visualise three snapshots of displacements that roughly correspond to LGM, the end of the meltwater pulse 1A and the present-day:\n\ncopts = (colormap = :PuOr, colorrange = (-500, 500))\nfig = plot_out_over_time(sim, :u_tot, [-26e3, -12e3, 0], copts)\n\nThis looks very much like what is obtained by Seakon (Swierczek-Jereczek et al., 2024, Fig.9.g), a 3D GIA model.","category":"section"},{"location":"examples/alternative_models/#Alternative-models","page":"Alternative models","title":"Alternative models","text":"","category":"section"},{"location":"examples/alternative_models/#ELRA","page":"Alternative models","title":"ELRA","text":"Sometimes people might want to use ELRA (LeMeur & Huybrechts, 1996):\n\nusing FastIsostasy, CairoMakie\n\nT, W, n = Float32, 3f6, 7\ndomain = RegionalDomain(W, n, correct_distortion = false)\n\nH_ice_0 = zeros(domain)\nH_ice_1 = 1f3 .* (domain.R .< 1f6)\nt_ice = [0, 1, 5f4]\nH_ice = [H_ice_0, H_ice_1, H_ice_1]\nit = TimeInterpolatedIceThickness(t_ice, H_ice, domain)\nbcs = BoundaryConditions(domain, ice_thickness = it)\nsealevel = RegionalSeaLevel()\n\nsolidearth = SolidEarth(\n    domain,\n    tau = 3f3,\n    lithosphere = RigidLithosphere(),\n    mantle = RelaxedMantle(),\n)\nnout = NativeOutput(vars = [:u, :ue, :dz_ss, :H_ice],\n    t = [0, 1f2, 3f2, 1f3, 3f3, 1f4, 2f4, 5f4])\n\nsim = Simulation(domain, bcs, sealevel, solidearth; nout = nout)\nrun!(sim)\nprintln(\"Took $(sim.nout.computation_time) seconds!\")\n\nfig = plot_transect(sim, [:u])","category":"section"},{"location":"examples/alternative_models/#ELRA-with-2D-relaxation-time","page":"Alternative models","title":"ELRA with 2D relaxation time","text":"Sometimes people might want to use ELRA with 2D maps of the relaxation time (Van Calcar et al., 2025)\n\nusing LinearAlgebra\n\nsigma = diagm([(W/4)^2, (W/4)^2])\nlog10visc = generate_gaussian_field(domain, 21f0, [0f0, 0], -1f0, sigma)\nheatmap(log10visc)\nτ_weak = get_relaxation_time_weaker.(10 .^ log10visc)\nprintln(\"Extrema of weak 2D relaxation time: $(extrema(τ_weak))\")\n\nsolidearth_weak = SolidEarth(\n    domain,\n    tau = T.(τ_weak),\n    lithosphere = RigidLithosphere(),\n    mantle = RelaxedMantle(),\n)\nsim_weak = Simulation(domain, bcs, sealevel, solidearth_weak; nout = nout)\nrun!(sim_weak)\nfig = plot_transect(sim_weak, [:u])\n\nAlternatively:\n\nτ_strong = get_relaxation_time_stronger.(10 .^ log10visc)\nprintln(\"Extrema of strong 2D relaxation time: $(extrema(τ_strong))\")\n\nsolidearth_strong = SolidEarth(\n    domain,\n    tau = T.(τ_strong),\n    lithosphere = RigidLithosphere(),\n    mantle = RelaxedMantle(),\n)\nsim_strong = Simulation(domain, bcs, sealevel, solidearth_strong; nout = nout)\nrun!(sim_strong)\nprintln(\"Computation time (s): $(sim.nout.computation_time)\")\nfig = plot_transect(sim_strong, [:u])","category":"section"},{"location":"#FastIsostasy.jl","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"❄ Fast and flexible glacial isostatic adjustment on CPU and GPU.\n\nwarning: Upgrade to v2.0!\nFastIsostasy.jl has been refactored under v2.0 to fix some performance issues, offer a more versatile API and propose new features. We strongly encourage to download v2.0 by running:] add https://github.com/JanJereczek/FastIsostasy.jlThis version will soon be registered and available through the usual Pkg.add(\"FastIsostasy\") command.\n\n(Image: GlacialCycle)\n\nFastIsostasy is a collection of models to compute the regional glacial isostatic adjustment (GIA) resulting from changes in the surface load (ice, liquid water and sediments). It is:\n\nAccessible: you can set up complex simulations with only a few lines of code, as demonstrated for the case of the last glacial cycle.\nFlexible: you can easily permute parameters and modelling choices to play Earth System Modelling like it's lego.\nPerformant: the results obtained only marginally differ from those obtained by 1D and 3D GIA models, while displaying a speed-up of 2 to 6 orders of magnitude.\n\ntip: Star us on GitHub!\nIf you have found this library useful, please consider starring it on GitHub. This gives us a lower bound of the satisfied user count.","category":"section"},{"location":"#Getting-started","page":"FastIsostasy.jl","title":"Getting started","text":"FastIsostasy.jl is a registered julia package. To install it, simply run:\n\nusing Pkg\nPkg.add(\"FastIsostasy\")","category":"section"},{"location":"#How-to-read-the-docs?","page":"FastIsostasy.jl","title":"How to read the docs?","text":"If you want a quick introduction to GIA, please go to Quick intro to GIA. If you want to have a thorough but still accessbile introduction to GIA, we highly recommend reading Whitehouse et al. (2019). If you want to get started right away, feel free to directly go to the examples. If you face any problem using the code or want to know more about the functionalities of the package, visit the Public API. If you face a problem you cannot solve, please open a GitHub issue with a minimal and reproduceable example. We also welcome feature requests!","category":"section"},{"location":"#How-to-cite?","page":"FastIsostasy.jl","title":"How to cite?","text":"Swierczek-Jereczek, J., Montoya, M., Latychev, K., Robinson, A., Alvarez-Solas, J., & Mitrovica, J. (2024). FastIsostasy v1.0 – a regional, accelerated 2D glacial isostatic adjustment (GIA) model accounting for the lateral variability of the solid Earth. Geoscientific Model Development, 17(13), 5263-5290.","category":"section"},{"location":"#Juliaecosystem","page":"FastIsostasy.jl","title":"Julia ecosystem","text":"FastIsostasy.jl was written thanks to the sheer amount of work that people invested in the vast and well-documented Julia ecosystem. Major help from packages deserves major appreciation, in particular for:\n\nFFTW.jl\nCUDA.jl\nParallelStencil.jl\nInterpolations.jl\nOrdinaryDiffEq.jl\nSpecialFunctions.jl\nFastGaussQuadrature.jl\nProj.jl\nAnd all the fantastic development tools that ease the every-day work so much: Documenter.jl, Literate.jl, Test.jl and DocumenterCitations.jl. Oceananigans and SpeedyWeather provided fantastic templates in terms of API, code structure and documentation.","category":"section"}]
}
