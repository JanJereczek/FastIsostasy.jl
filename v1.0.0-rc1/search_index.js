var documenterSearchIndex = {"docs":
[{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"EditURL = \"glacialcycle.jl\"","category":"page"},{"location":"examples/glacialcycle/#Glacial-cycle","page":"Glacial cycle","title":"Glacial cycle","text":"","category":"section"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"We now want to provide an example that presents:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"a heterogeneous lithosphere thickness\na heterogeneous upper-mantle viscosity\na stack of few viscous channels\na more elaborate load that evolves over time\nchanges in the sea-level","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"For this we run a glacial cycle of Antarctica with lithospheric thickness and upper-mantle viscosity from (Wiens et al., 2022) and the ice thickness history from (Argus et al., 2014). We start by generating a ComputationDomain with intermediate resolution for the sake of the example and load the heterogeneous lithospheric from (Pan et al., 2022) thanks to the convenience of load_dataset:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"using CairoMakie, FastIsostasy\n\nN = 140\nOmega = ComputationDomain(3500e3, 3500e3, N, N)     # 100 km resolution\n(; Lon, Lat) = Omega\nc = PhysicalConstants()\n\n(_, _), Tpan, Titp = load_lithothickness_pan2022()\nTlitho = Titp.(Lon, Lat) .* 1e3                     # convert from m to km\n\nfunction niceheatmap(X)\n    fig = Figure(resolution = (800, 700))\n    ax = Axis(fig[1, 1], aspect = DataAspect())\n    hidedecorations!(ax)\n    hm = heatmap!(ax, X)\n    Colorbar(fig[1, 2], hm, height = Relative(0.6))\n    return fig\nend\nniceheatmap(Tlitho)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"In a similar way, we can load the log-viscosity field from (Pan et al., 2022) and plot it at about 300 km depth","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"(_, _, _), _, logeta_itp = load_logvisc_pan2022()\nlogeta300 = logeta_itp.(Lon, Lat, c.r_equator - 300e3)\nniceheatmap(logeta300)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"The number of layers and the depth of viscous half-space are arbitrary parameters that have to be defined by the user. We here use a relatively shallow model (half-space begins at 300 km depth) with 1 equalisation layer and 3 intermediate layers:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"mindepth = maximum(Tlitho) + 1e3\nlb_vec = range(mindepth, stop = 300e3, length = 3)\nlb = cat(Tlitho, [fill(lbval, Omega.Nx, Omega.Ny) for lbval in lb_vec]..., dims=3)\n\nrlb = c.r_equator .- lb\nnlb = size(rlb, 3)\nlv_3D = 10 .^ cat([logeta_itp.(Lon, Lat, rlb[:, :, k]) for k in 1:nlb]..., dims=3);\nnothing #hide","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"To prevent extreme values of the viscosity, we require it to be larger than a minimal value, fixed to be $ 10^{16} \\, \\mathrm{Pa \\, s} $. We subsequently generate a LayeredEarth that embeds all the information that has been loaded so far:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"eta_lowerbound = 1e16\nlv_3D[lv_3D .< eta_lowerbound] .= eta_lowerbound\np = LayeredEarth(Omega, layer_boundaries = lb, layer_viscosities = lv_3D)\nniceheatmap(p.effective_viscosity)","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"We now load the ice thickness history from ICE6GD, again helped by the convenience of [`loaddataset`](@ref). We then create a vector of anomaly snapshots, between which FastIsostasy automatically interpolates linearly. To get an idea of ICE6G_D, the ice thickness anomaly is then visualised at LGM:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"(lon, lat, t), Hice, Hitp = load_ice6gd()\ndHice = [Hitp.(Lon, Lat, tk) - Hitp.(Lon, Lat, minimum(t)) for tk in t]\nniceheatmap(Hitp.(Lon, Lat, -26) - Hitp.(Lon, Lat, 0))","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"Finally, defining and solving the resulting FastIsoProblem is done by running:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"tsec = years2seconds.(t .* 1e3)\nfip = FastIsoProblem(Omega, c, p, tsec, tsec, dHice)\nsolve!(fip)     # gives fip.out.computation_time = 53 s","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"The computation time of this last step is less than a minute on a modern i7 (Intel i7-10750H CPU @ 2.60GHz). and for a resolution of 50 km resolution! We visualise three snapshots of displacements that roughly correspond to LGM, the end of the meltwater pulse 1A and the present-day:","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"tplot = [-26, -12, 0]\nfig = Figure(resolution = (1800, 600))\nopts = ( colormap = :PuOr, colorrange = (-400, 400) )\nfor k in eachindex(tplot)\n    ax = Axis(fig[1, k], aspect = DataAspect())\n    hidedecorations!(ax)\n    kfi = argmin( abs.(years2seconds(tplot[k] * 1e3) .- tsec) )\n    heatmap!(ax, fip.out.u[kfi] + fip.out.ue[kfi]; opts...)\n    println(kfi)\nend\nColorbar(fig[1, 4], height = Relative(0.6); opts...)\nfig","category":"page"},{"location":"examples/glacialcycle/","page":"Glacial cycle","title":"Glacial cycle","text":"The displayed fields are displacement anomalies w.r.t. to the last interglacial, defined as the reference for the ice thickness anomalies. In (Swierczek-Jereczek et al. in prep.), these computations are performed on a finer grid, with an interactive sea level, and show great agreement with a 3D GIA model that runs between 10,000-100,000 slower (however at with advantage of obtaining a global and richer output).","category":"page"},{"location":"references/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"references/","page":"Bibliography","title":"Bibliography","text":"Argus, D. F.; Peltier, W. R.; Drummond, R. and Moore, A. W. (2014). The Antarctica component of postglacial rebound model ICE-6G-C (VM5a) based on GPS positioning, exposure age dating of ice thicknesses, and relative sea level histories. Geophysical Journal International 198, 537–563. Accessed on Sep 21, 2023.\n\n\n\nBueler, E.; Lingle, C. S. and Brown, J. (2007). Fast computation of a viscoelastic deformable Earth model for ice-sheet simulations. Annals of Glaciology 46, 97–105. Accessed on Nov 15, 2022.\n\n\n\nCathles, L. M. (1975). Viscosity of the Earth's Mantle (Princeton University Press).\n\n\n\nCoulon, V.; Bulthuis, K.; Whitehouse, P. L.; Sun, S.; Haubner, K.; Zipf, L. and Pattyn, F. (2021). Contrasting Response of West and East Antarctic Ice Sheets to Glacial Isostatic Adjustment. Journal of Geophysical Research: Earth Surface 126. Accessed on Jan 30, 2023.\n\n\n\nGomez, N.; Latychev, K. and Pollard, D. (2018). A Coupled Ice Sheet–Sea Level Model Incorporating 3D Earth Structure: Variations in Antarctica during the Last Deglacial Retreat. Journal of Climate 31, 4041–4054. Accessed on Dec 19, 2022.\n\n\n\nHuang, D. Z. and Huang, J. (Feb 2021). Improve Unscented Kalman Inversion With Low-Rank Approximation and Reduced-Order Model. Accessed on Sep 22, 2023, arXiv:2102.10677 [cs, math].\n\n\n\nHuang, D. Z.; Schneider, T. and Stuart, A. M. (2021). Unscented Kalman Inversion, arXiv.\n\n\n\nIvins, E. R.; van der Wal, W.; Wiens, D. A.; Lloyd, A. J. and Caron, L. (2022). Antarctic upper mantle rheology. Geological Society, London, Memoirs 56, M56–2020–19. Accessed on Nov 29, 2022.\n\n\n\nLingle, C. S. and Clark, J. A. (1985). A numerical model of interactions between a marine ice sheet and the solid earth: Application to a West Antarctic ice stream. Journal of Geophysical Research 90, 1100. Accessed on Nov 23, 2022.\n\n\n\nPan, L.; Milne, G. A.; Latychev, K.; Goldberg, S. L.; Austermann, J.; Hoggard, M. J. and Mitrovica, J. X. (2022). The influence of lateral Earth structure on inferences of global ice volume during the Last Glacial Maximum. Quaternary Science Reviews 290, 107644. Accessed on Oct 4, 2023.\n\n\n\nVan Calcar, C. J.; Van De Wal, R. S.; Blank, B.; De Boer, B. and Van Der Wal, W. (2023). Simulation of a fully coupled 3D glacial isostatic adjustment – ice sheet model for the Antarctic ice sheet over a glacial cycle. Geoscientific Model Development 16, 5473–5492. Accessed on Sep 28, 2023.\n\n\n\nWhitehouse, P. L.; Gomez, N.; King, M. A. and Wiens, D. A. (2019). Solid Earth change and the evolution of the Antarctic Ice Sheet. Nature Communications 10, 503. Accessed on Nov 15, 2022.\n\n\n\nWiens, D. A.; Shen, W. and Lloyd, A. J. (2022). The seismic structure of the Antarctic upper mantle. Geological Society, London, Memoirs 56, M56–2020–18. Accessed on Dec 1, 2022.\n\n\n\n","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"EditURL = \"inversion.jl\"","category":"page"},{"location":"examples/inversion/#Parameter-inversion","page":"Parameter inversion","title":"Parameter inversion","text":"","category":"section"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"FastIsostasy relies on simplifications of the full GIA problem and might therefore need a calibration step to match the data, typically obtained from observations or from a \"golden-standard\" 3D GIA model. By means of an unscented Kalman inversion (Huang et al., 2021; Huang and Huang, Feb 2021), one can, for instance, infer the appropriate field of effective mantle viscosity that matches the data best. Whereas this is known to be a tedious step, FastIsostasy is developped to ease the procedure by providing a convenience struct InversionProblem. We demonstrate this on a low-resolution grid since (1) the underlying unscented Kalman filter requires many simulations and (2) estimating high-resolution viscosity field might lead to overfit the problem. The effective viscosity field we estimate(Wiens et al., 2022) can be loaded by using load_dataset with appropriate depths of the layer boundaries:","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"using CairoMakie, FastIsostasy\nOmega = ComputationDomain(3000e3, 5)\nc = PhysicalConstants()\nlb = [100e3, 200e3, 300e3]\n_, eta, eta_itp = load_dataset(\"Wiens2022\")\nloglv = cat([eta_itp.(Omega.X, Omega.Y, z) for z in lb]..., dims = 3)\nlv = 10 .^ loglv\np = LayeredEarth(Omega, layer_boundaries = lb, layer_viscosities = lv)\nheatmap(p.effective_viscosity)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"To make this problem more exciting, we shift the center of the ice load to $ (-1000, -1000) \\: \\mathrm{km} $ where the viscosity field displays a less uniform structure. For the sake of simplicity, the data to fit is obtained from a FastIsostasy simulation with the ground-truth viscosity field.","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"R, H = 1000e3, 1e3\nHcylinder = uniform_ice_cylinder(Omega, R, H, center = [-1000e3, -1000e3])\nHice = [zeros(Omega.Nx, Omega.Ny), Hcylinder, Hcylinder]\nt_out = years2seconds.(collect(1e3:1e3:2e3))\npushfirst!(t_out, t_out[1]-1e-8)\nt_Hice = copy(t_out)\n\ntrue_viscosity = copy(p.effective_viscosity)\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice)\nsolve!(fip)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"Now that we have the displacement field, we can recover the viscosity field from which it results. We therefore pass an InversionConfig and an InversionData to an InversionProblem. Let's look at the initialized viscosity field:","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"config = InversionConfig(N_iter = 15)\ndata = InversionData(copy(fip.out.t[2:end]), copy(fip.out.u[2:end]), copy(Hice[2:end]),\n    config)\nparaminv = InversionProblem(deepcopy(fip), config, data)\n\nfunction plot_viscfields(paraminv)\n    estim_viscosity = copy(true_viscosity)\n    estim_viscosity[paraminv.data.idx] .= 10 .^ get_ϕ_mean_final(\n        paraminv.priors, paraminv.ukiobj)\n\n    cmap = cgrad(:jet, rev = true)\n    crange = (19.5, 21.5)\n    fig = Figure(resolution = (1800, 1000), fontsize = 40)\n    axs = [Axis(fig[1,i], aspect = DataAspect()) for i in 1:2]\n    [hidedecorations!(ax) for ax in axs]\n    heatmap!(axs[1], log10.(true_viscosity), colormap = cmap, colorrange = crange)\n    heatmap!(axs[2], log10.(estim_viscosity), colormap = cmap, colorrange = crange)\n    Colorbar(fig[2, :], vertical = false, colormap = cmap, colorrange = crange,\n        width = Relative(0.5))\n    return fig\nend\nfig1 = plot_viscfields(paraminv)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"By performing a Kalman inversion, we can achieve a close match between ground truth and estimated viscosity field:","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"solve!(paraminv)\nfig2 = plot_viscfields(paraminv)","category":"page"},{"location":"examples/inversion/","page":"Parameter inversion","title":"Parameter inversion","text":"This remains an academic example, where we try to recover a known parameter field from data generated by the model itself. Nonetheless, the user should get a proof-of-concept and a scheme of how to implement such a procedure themself.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this section, we will present some examples with idealised loads and solid-Earth parameters. This should give the user a basic understanding of FastIsostasy's basic functions.","category":"page"},{"location":"examples/tutorial/#D-2D-Earth","page":"Tutorial","title":"3D ➡ 2D Earth","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"FastIsostasy relies on a (polar) stereographic projection. Let's first create Omega::ComputationDomain and visualise how this relates to a domain on a spherical Earth:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie, FastIsostasy\n\nW = 3000e3      # (m) half-width of the domain Wx = Wy\nn = 7           # implies an Nx x Ny grid with Nx = Ny = 2^n = 128.\nOmega = ComputationDomain(W, n)\nfig = Figure(resolution = (1600, 800), fontsize = 24)\naxs = [Axis3(fig[1, j], title = [\"Original grid\", \"Projected grid\"][j]) for j in 1:2]\nwireframe!(axs[1], Omega.X .* Omega.K, Omega.Y .* Omega.K,\n    Omega.R .* cos.(deg2rad.(Omega.Lat)), color = :gray10, linewidth = 0.1)\nwireframe!(axs[2], Omega.X .* Omega.K, Omega.Y .* Omega.K,\n    Omega.null, color = :gray10, linewidth = 0.1)\nfor ax in axs\n    zlims!(ax, (0, 5e6))\n    hidedecorations!(ax)\n    hidespines!(ax)\nend\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The distortion factor Omega.K is not only accessible but also accounted for in all the computations. The projection allows to treat the radially-layered, onion-like structure of the solid Earth as a superposition of horizontal layers. Furthermore, FastIsostasy reduces this 3D problem into a 2D problem by collapsing the depth dimension, mainly through the computation of an effective viscosity field that accounts for the superposition of layers with different viscosities. The user is required to provide the 3D information, which will then be used under the hood to compute the effective viscosity. This tutorial shows such an example.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We want to render a situation similar to the one depicted below:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Schematic representation of the three-layer set-up.)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Initializing a LayeredEarth with parameters corresponding to this situation automatically computes the conversion from a 3D to a 2D problem. Since we will compare our solution to an analytical one of a flat Earth, we exceptionally switch off the distortion correction. This can be simply executed by running:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Omega = ComputationDomain(W, n, correct_distortion = false)\nc = PhysicalConstants(rho_litho = 0.0)\nlv = [1e19, 1e21]       # viscosity layers (Pa s)\nlb = [88e3, 400e3]      # depth of layer boundaries (m)\np = LayeredEarth(Omega, layer_viscosities = lv, layer_boundaries = lb)\nextrema(p.effective_viscosity)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the effective viscosity is a homogeneous field. It corresponds to a nonlinear mean of the layered values provided by the user. Note that we have set $ \\ŗho{litho} = 0 $ to prevent the lithosphere from contributing to the hydrostatic, upward force. This is made to comply with the later computed analytical solution, which assumes a purely elastic lithosphere that does not generate a hydrostatic upward force when displaced. In reality, this is arguably wrong and the default choice c = PhysicalConstants() therefore uses $ \\ŗho{litho} = 2600 \\, \\mathrm{kg \\, m^{-3}} $.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The next section shows how to use the now obtained p::LayeredEarth for actual GIA computation.","category":"page"},{"location":"examples/tutorial/#Simple-load-and-geometry","page":"Tutorial","title":"Simple load and geometry","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We now apply a constant load, here a cylinder of ice with radius $ R = 1000 \\, \\mathrm{km} $ and thickness H = 1  mathrmkm, over Omega::ComputationDomain introduced in LayeredEarth. To formulate the problem conviniently, we use FastIsoProblem, a struct containing the variables and options that are necessary to perform the integration over time. We can then simply apply solve!(fip::FastIsoProblem) to perform the integration of the ODE. Under the hood, the ODE is obtained from the PDE by applying a Fourier collocation scheme contained in dudt_isostasy!. The integration is performed according to FastIsoProblem.diffeq::NamedTuple, which contains the algorithm and optionally tolerances, maximum iteration number... etc.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"R = 1000e3                  # ice disc radius (m)\nH = 1e3                     # ice disc thickness (m)\nHcylinder = uniform_ice_cylinder(Omega, R, H)\nHice = [zeros(Omega.Nx, Omega.Ny), Hcylinder, Hcylinder]\n\nt_out = years2seconds.([0.0, 200.0, 600.0, 2000.0, 5000.0, 10_000.0, 50_000.0])\nεt = 1e-8\npushfirst!(t_out, -εt)\nt_Hice = [-εt, 0.0, t_out[end]]\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice)\nsolve!(fip)\n\nfunction plot3D(fip, k_idx)\n    X, Y, out = Array(fip.Omega.X), Array(fip.Omega.Y), fip.out\n    zl = extrema(out.ue[end] + out.u[end])\n    fig = Figure(fontsize = 10)\n    for j in eachindex(k_idx)\n        ax = Axis3(fig[1, j])\n        u_tot = out.ue[k_idx[j]] + out.u[k_idx[j]]\n        surface!(ax, X, Y, u_tot, colormap = :cool)\n        wireframe!(ax, X, Y, u_tot, color = :black, linewidth = 0.1)\n        zlims!(ax, zl)\n    end\n    return fig\nend\nfig = plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"... and here goes the total displacement at t = 50  mathrmkyr. You can now access the elastic and viscous displacement at time t_out[k] by respectively calling fip.out.ue[k] and fip.out.u[k]. For the present case, the latter can be compared to an analytic solution that is known for this particular case. Let's look at the accuracy of our numerical scheme over time by running following plotting commands:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"fig = Figure()\nax = Axis(fig[1, 1])\ncmap = cgrad(:jet, length(t_out), categorical = true)\nii, jj = Omega.Mx:Omega.Nx, Omega.My\nx = Omega.X[ii, jj]\nr = Omega.R[ii, jj]\n\nfor k in eachindex(t_out)\n    analytic_solution_r(r) = analytic_solution(r, t_out[k], c, p, H, R)\n    u_analytic = analytic_solution_r.(r)\n    u_numeric = fip.out.u[k][ii, jj]\n    lines!(ax, x, u_analytic, color = cmap[k], linewidth = 5,\n        label = L\"$u_{ana}(t = %$(round(seconds2years(t_out[k]))) \\, \\mathrm{yr})$\")\n    lines!(ax, x, u_numeric, color = cmap[k], linewidth = 5, linestyle = :dash,\n        label = L\"$u_{num}(t = %$(round(seconds2years(t_out[k]))) \\, \\mathrm{yr})$\")\nend\naxislegend(ax, position = :rb, nbanks = 2, patchsize = (50.0f0, 20.0f0))\nfig","category":"page"},{"location":"examples/tutorial/#GPU-support","page":"Tutorial","title":"GPU support","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"For about n geq 7, the present example can be computed even faster by using GPU parallelism. It could not represent less work from the user's perspective, as it boils down to calling ComputationDomain with an extra keyword argument and passing it to a ::LayeredEarth with the viscosity and depth values defined earlier:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Omega = ComputationDomain(W, n, use_cuda = true)\np = LayeredEarth(Omega, layer_viscosities = lv, layer_boundaries = lb)\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice)\nsolve!(fip)\nfig = plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it, nothing more! For postprocessing, consider using reinit_structs_cpu.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Only CUDA supported!\nFor now only Nvidia GPUs are supported and there is no plan of extending this compatibility at this point.","category":"page"},{"location":"examples/tutorial/#Make-your-own-time-loop","page":"Tutorial","title":"Make your own time loop","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"As any high-level function, solve! has some limitations. An ice-sheet modeller typically wants to embed FastIsostasy within a time-stepping loop. This can be easily done by getting familiar with some intermediate-level functions like init, step! and write_out!:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Omega = ComputationDomain(3000e3, n)\np = LayeredEarth(Omega)\nfip = FastIsoProblem(Omega, c, p, t_out, t_Hice, Hice)\n\nupdate_diagnostics!(fip.now.dudt, fip.now.u, fip, 0.0)\nwrite_out!(fip, 1)\node = init(fip)\n@inbounds for k in eachindex(fip.out.t)[2:end]\n    step!(fip, ode, (fip.out.t[k-1], fip.out.t[k]))\n    write_out!(fip, k)\nend\nfig = plot3D(fip, [lastindex(t_out) ÷ 2, lastindex(t_out)])","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Coupling to julia Ice-Sheet model\nIn case your Ice-Sheet model is programmed in julia, we highly recommend performing the coupling within the function updating the derivatives and let OrdinaryDiffEq.jl handle the rest.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: GPU not supported\nstep! does not support GPU computation so far. Make sure your model is initialized on CPU.","category":"page"},{"location":"fortran/#Fortran-version","page":"Fortran version","title":"Fortran version","text":"","category":"section"},{"location":"fortran/","page":"Fortran version","title":"Fortran version","text":"Since Julia does not allow compilation to binaries yet, some researchers might find it hard to couple FastIsostasy.jl to their favourite ice-sheet model. To tackle this, a Fortran code is under current development. It however lacks some features, which are summarised below:","category":"page"},{"location":"fortran/","page":"Fortran version","title":"Fortran version","text":"Library of time-integration methods reduced to explicit Euler and RK4,\nOnly fixed time stepping allowed,\nNo inversion routines for the UKI,\nComputation on GPU not supported.","category":"page"},{"location":"fortran/","page":"Fortran version","title":"Fortran version","text":"These discrepancies are unlikely to be gapped in the future, mostly because the Fortran ecosystem is less extensive than the Julia one.","category":"page"},{"location":"APIref/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"APIref/#Basic-structs","page":"API reference","title":"Basic structs","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"ComputationDomain\nPhysicalConstants\nLayeredEarth\nReferenceState\nCurrentState\nFastIsoTools\nSolverOptions\nOceanSurfaceChange\nFastIsoProblem","category":"page"},{"location":"APIref/#FastIsostasy.ComputationDomain","page":"API reference","title":"FastIsostasy.ComputationDomain","text":"ComputationDomain\nComputationDomain(W, n)\nComputationDomain(Wx, Wy, Nx, Ny)\n\nReturn a struct containing all information related to geometry of the domain and potentially used parallelism. To initialize one with 2*W and 2^n grid cells:\n\nOmega = ComputationDomain(W, n)\n\nIf a rectangular domain is needed, run:\n\nOmega = ComputationDomain(Wx, Wy, Nx, Ny)\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.PhysicalConstants","page":"API reference","title":"FastIsostasy.PhysicalConstants","text":"PhysicalConstants\n\nReturn a struct containing important physical constants. Comes with default values that can however be changed by the user, for instance by running:\n\nc = PhysicalConstants(rho_ice = 0.93)   # (kg/m^3)\n\nAll constants are given in SI units (kilogram, meter, second).\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.LayeredEarth","page":"API reference","title":"FastIsostasy.LayeredEarth","text":"LayeredEarth(Omega; layer_boundaries, layer_viscosities)\n\nReturn a struct containing all information related to the lateral variability of solid-Earth parameters. To initialize with values other than default, run:\n\nOmega = ComputationDomain(3000e3, 7)\nlb = [100e3, 300e3]\nlv = [1e19, 1e21]\np = LayeredEarth(Omega, layer_boundaries = lb, layer_viscosities = lv)\n\nwhich initializes a lithosphere of thickness T_1 = 100 mathrmkm, a viscous channel between T_1 and T_2 = 200 mathrmkm and a viscous halfspace starting at T_2. This represents a homogenous case. For heterogeneous ones, simply make lb::Vector{Matrix}, lv::Vector{Matrix} such that the vector elements represent the lateral variability of each layer on the grid of Omega::ComputationDomain.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.ReferenceState","page":"API reference","title":"FastIsostasy.ReferenceState","text":"ReferenceState\n\nReturn a struct containing the reference state.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.CurrentState","page":"API reference","title":"FastIsostasy.CurrentState","text":"CurrentState\n\nReturn a mutable struct containing the geostate which will be updated over the simulation. The geostate contains all the states of the [FastIsoProblem] to be solved.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.FastIsoTools","page":"API reference","title":"FastIsostasy.FastIsoTools","text":"FastIsoTools(Omega, c, p)\n\nReturn a struct containing pre-computed tools to perform forward-stepping of the model. This includes the Green's functions for the computation of the lithosphere and geoid displacement, plans for FFTs, interpolators of the load and the viscosity over time and preallocated arrays.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.SolverOptions","page":"API reference","title":"FastIsostasy.SolverOptions","text":"Options\n\nReturn a struct containing the options relative to solving a FastIsoProblem.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.OceanSurfaceChange","page":"API reference","title":"FastIsostasy.OceanSurfaceChange","text":"OceanSurfaceChange(; z0 = 0.0)\n\nReturn a mutable struct OceanSurfaceChange containing:\n\nz_k: the GMSL at current time step k.\nA_k: the ocean surface at current time step k.\nz: a vector of GMSL values used as knots for interpolation.\nA: a vector of ocean surface values used as knots for interpolation.\nA_itp: an interpolator of ocean surface over depth. Bias-free for present-day.\nA_pd: the present-day ocean surface.\nres: residual of the nonlinear equation solved numerically.\n\nAn osc::OceanSurfaceChange can be used as function to update osc.z_k and osc.A_k based on osc.A_itp and an input delta_V by running:\n\nosc(delta_V)\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.FastIsoProblem","page":"API reference","title":"FastIsostasy.FastIsoProblem","text":"FastIsoProblem(Omega, c, p, t_out)\nFastIsoProblem(Omega, c, p, t_out, Hice)\nFastIsoProblem(Omega, c, p, t_out, t_Hice, Hice)\n\nReturn a struct containing all the other structs needed for the forward integration of the model over Omega::ComputationDomain with parameters c::PhysicalConstants and p::LayeredEarth. The outputs are stored at t_out::Vector{<:AbstractFloat}.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#Mechanics","page":"API reference","title":"Mechanics","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"solve!(::FastIsoProblem)\ninit\nstep!\nupdate_diagnostics!\ndudt_isostasy!\nupdate_elasticresponse!","category":"page"},{"location":"APIref/#FastIsostasy.solve!-Tuple{FastIsoProblem}","page":"API reference","title":"FastIsostasy.solve!","text":"solve!(fip)\n\nSolve the isostatic adjustment problem defined in fip::FastIsoProblem.\n\n\n\n\n\n","category":"method"},{"location":"APIref/#FastIsostasy.init","page":"API reference","title":"FastIsostasy.init","text":"init(fip)\n\nInitialize an ode::CoupledODEs, aimed to be used in step!.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.step!","page":"API reference","title":"FastIsostasy.step!","text":"step!(fip)\n\nStep fip::FastIsoProblem over tspan and based on ode::CoupledODEs, typically obtained by init.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.update_diagnostics!","page":"API reference","title":"FastIsostasy.update_diagnostics!","text":"update_diagnostics!(dudt, u, fip, t)\n\nUpdate all the diagnotisc variables, i.e. all fields of fip.now apart from the displacement, which requires an integrator.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.dudt_isostasy!","page":"API reference","title":"FastIsostasy.dudt_isostasy!","text":"dudt_isostasy!()\n\nUpdate the displacement rate dudt of the viscous response.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.update_elasticresponse!","page":"API reference","title":"FastIsostasy.update_elasticresponse!","text":"update_elasticresponse!(fip::FastIsoProblem)\n\nUpdate the elastic response by convoluting the Green's function with the load anom. To use coefficients differing from [Farrell1972], see FastIsoTools.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#Parameter-inversion","page":"API reference","title":"Parameter inversion","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"InversionConfig\nInversionData\nInversionProblem\nsolve!(::InversionProblem)","category":"page"},{"location":"APIref/#FastIsostasy.InversionConfig","page":"API reference","title":"FastIsostasy.InversionConfig","text":"InversionConfig\n\nStruct containing configuration parameters for a [InversionProblem].\n\nNeed to choose regularization factor α ∈ (0,1],   When you have enough observation data α=1: no regularization\n\nupdate_freq 1 : approximate posterior cov matrix with an uninformative prior             0 : weighted average between posterior cov matrix with an uninformative prior and prior\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.InversionData","page":"API reference","title":"FastIsostasy.InversionData","text":"InversionData\n\nStruct containing data (either observational or output of a golden standard model) for a [InversionProblem].\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.InversionProblem","page":"API reference","title":"FastIsostasy.InversionProblem","text":"InversionProblem\n\nStruct containing variables and configs for the inversion of Solid-Earth parameter fields. For now, only viscosity can be inverted but future versions will support lithosphere rigidity. For now, the unscented Kalman inversion is the only method available but ensemble Kalman inversion will be available in future.\n\n\n\n\n\n","category":"type"},{"location":"APIref/#FastIsostasy.solve!-Tuple{InversionProblem}","page":"API reference","title":"FastIsostasy.solve!","text":"solve!(paraminv::InversionProblem)\n\nReturn priors and ukiobj that allow to extract the results of the parameter inversion as initialized in paraminv.\n\n\n\n\n\n","category":"method"},{"location":"APIref/#Convenience","page":"API reference","title":"Convenience","text":"","category":"section"},{"location":"APIref/","page":"API reference","title":"API reference","text":"load_dataset\nreinit_structs_cpu\nwrite_out!\nsavefip","category":"page"},{"location":"APIref/#FastIsostasy.load_dataset","page":"API reference","title":"FastIsostasy.load_dataset","text":"load_dataset(name) → (dims), field, interpolator\n\nReturn the dims::Tuple{Vararg{Vector}}, the field<:Array and the interpolator corresponding to a data set defined by a unique name::String. For instance:\n\n(lon180, lat, t), Hice, Hice_itp = load_dataset(\"ICE6G_D\")\n\nFollowing options are available for parameter fields:\n\n\"ICE6GD\": ice loading history from ICE6GD.\n\"Wiens2022\": viscosity field from (Wiens et al. 2022)\n\"Lithothickness_Pan2022\": lithospheric thickness field from (Pan et al. 2022)\n\"Viscosity_Pan2022\": viscosity field from (Pan et al. 2022)\n\nFollowing options are available for model results:\n\n\"Spada2011\"\n\"LatychevGaussian\"\n\"LatychevICE6G\"\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.reinit_structs_cpu","page":"API reference","title":"FastIsostasy.reinit_structs_cpu","text":"reinit_structs_cpu(Omega, p)\n\nReinitialize Omega::ComputationDomain and p::LayeredEarth on the CPU, mostly for post-processing purposes.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.write_out!","page":"API reference","title":"FastIsostasy.write_out!","text":"write_out!(fip::FastIsoProblem)\n\nWrite results in output vectors if the load is updated internally. If the load is updated externally, the user is responsible for writing results.\n\n\n\n\n\n","category":"function"},{"location":"APIref/#FastIsostasy.savefip","page":"API reference","title":"FastIsostasy.savefip","text":"savefip(filename, fip; T = Float32)\n\nSave the output of fip::FastIsoProblem as NetCDF file under filename.\n\n\n\n\n\n","category":"function"},{"location":"#FastIsostasy.jl","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"❄ Fast and friendly glacial isostatic adjustment on CPU and GPU.","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"(Image: GlacialCycle)","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy is a friendly and flexible model that regionally computes the glacial isostatic adjustment (GIA) with laterally-variable mantle viscosity and lithospheric thickness. It is mainly adressed to ice-sheet modellers who seek for (1) a good representation of solid-Earth mechanics at virtually zero computational cost, (2) an approximation of the sea-level equation and (3) ready-to-use inversion tools to calibrate the model parameters to data. The simple interface of FastIsostasy allows to flexibly solve GIA problems within few lines of code. It is fully open-source under MIT license and was succesfully benchmarked against analytical, 1D GIA and 3D GIA model solutions.","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy relies on a hybrid Fourier/finite-difference collocation of the problem introduced in (Cathles, 1975) and solved in (Lingle and Clark, 1985), (Bueler et al., 2007). Thanks to a simplification of the full problem from 3D to 2D space and the use of optimized software packages, running kiloyears of regional GIA with Delta x = Delta y simeq 45  mathrmkm is a matter of seconds on a single CPU. For high resolution runs, the user can switch to GPU usage with minimal syntax change and enjoy the advantage of parallelization without requiring an HPC cluster. For GIA \"purists\", this package is likely to miss interesting processes but we belive that its ridiculous run-time can help to fast-prototype a problem before transfering it to a more comprehensive model.","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"tip: Star us on GitHub!\nIf you have found this library useful, please consider starring it on GitHub. This gives us a lower bound of the satisfied user count.","category":"page"},{"location":"#Getting-started","page":"FastIsostasy.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy.jl is a registered julia package. To install it, please run:","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"using Pkg\nPkg.add(\"FastIsostasy\")","category":"page"},{"location":"#How-to-read-the-docs?","page":"FastIsostasy.jl","title":"How to read the docs?","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"If you want a quick introduction to GIA, please go to Quick intro to GIA. If you want to have a thorough but still accessbile introduction to GIA, we highly recommend reading (Whitehouse et al., 2019). If you want to get started right away, feel free to directly go to the Tutorial. If you face any problem using the code or want to know more about the functionalities of the package, visit the API reference. If you face a problem you cannot solve, please open a GitHub issue with a minimal and reproduceable example. We also welcome feature requests!","category":"page"},{"location":"#Juliaecosystem","page":"FastIsostasy.jl","title":"Julia ecosystem","text":"","category":"section"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FastIsostasy.jl was written thanks to the sheer amount of work that people invested in the vast and well-documented Julia ecosystem. Major help from packages deserves major appreciation, in particular for:","category":"page"},{"location":"","page":"FastIsostasy.jl","title":"FastIsostasy.jl","text":"FFTW.jl\nCUDA.jl\nParallelStencil.jl\nInterpolations.jl\nOrdinaryDiffEq.jl\nDynamicalSystemsBase.jl\nKalmanEnsembleProcesses.jl\nSpecialFunctions.jl\nFastGaussQuadrature.jl\nAnd all the fantastic development tools that ease the every-day work so much: Documenter.jl, Literate.jl, Test.jl and DocumenterCitations.jl. Despite being quite unrelated, Oceananigans was a great template of how well geoscientific models can be documented.","category":"page"},{"location":"introGIA/#Quick-intro-to-GIA","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"","category":"section"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"Glacial isostatic adjustment (GIA) denotes the crustal displacement that results from changes in the ice, liquid water and sediment columns, as well as associated changes in Earth's gravity and rotation axis, ultimately impacting the sea level. The magnitude and time scale of the deformational response depends on the applied load and on solid-Earth parameters, i.e. the mantle viscosity, the lithosphere thickness and their respective density. These parameters display a radial and sometimes also a lateral variability, further jointly denoted by parameter \"heterogeneity\". For further details, please refer to (Wiens et al., 2022) and (Ivins et al., 2022).","category":"page"},{"location":"introGIA/#Why-do-we-care?","page":"Quick intro to GIA","title":"Why do we care?","text":"","category":"section"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"GIA is known to present many feedbacks on ice-sheet evolution. Their net effect is negative, meaning that GIA inhibits ice-sheet growth and retreat. In other words, it tends to stabilize a given state and is therefore particularly important in the context of paleo-climate and climate change.","category":"page"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"The speed and magnitude of anthropogenic warming is a potential threat to the Greenland and the West-Antarctic ice sheets. They both represent an ice volume that could lead to multi-meter sea-level rise. The effect of GIA in this context appears to be particularly relevant - not only from a theoretical but also from a practical perspective, as a large portion of human livelihoods are concentrated along coasts.","category":"page"},{"location":"introGIA/#GIA-models-for-ice-sheet-simulation","page":"Quick intro to GIA","title":"GIA models for ice-sheet simulation","text":"","category":"section"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"GIA models present a wide range of complexity, which can only be briefly mentioned here. On the lower end, models such as the Elastic-Lithopshere/Viscous-Asthenopshere are cheap to run and easy to implement, which has made them popular within the ice-sheet modelling community. They present some acceptable limitations such as regionally approximating a global problem and lacking the radially layered structure of the solid Earth. However, some limitations have shown to be too important to be overlooked:","category":"page"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"The GIA response is independent of the load's wavelength.\nThe heterogeneity of the lithospheric thickness and upper-mantle viscosity cannot be represented.\nChanges in sea-surface height due to changes in mass repartition are ignored.","category":"page"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"On the higher end of the complexity spectrum, we find the 3D GIA models which address all the limitations of low-complexity models but are expensive to run, more tedious to couple to an ice-sheet model and generally lack a well-documented and open-source code base. Due to these drawbacks, they do not represent a standard tool within the ice-sheet modelling community. Although, they are becoming increasingly used, as for instance in (Gomez et al., 2018) and (Van Calcar et al., 2023), we believe that the expense of 3D GIA models can be avoided while still addressing the aforementioned limitations of simplistic models. Models specifically designed for ice-sheet modelling, such as (Bueler et al., 2007) and (Coulon et al., 2021), have shown first improvements in closing the gap between simplistic and expensive models. FastIsostasy continues this work by generalizing both of these contributions into one","category":"page"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"We here omit to speak about other GIA models, since they lack the representation of heterogeneous solid-Earth parameters.","category":"page"},{"location":"introGIA/#FastIsosatsy.jl-in-the-model-hierarchy","page":"Quick intro to GIA","title":"FastIsosatsy.jl in the model hierarchy","text":"","category":"section"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"FastIsostasy is capable of regionally reproducing the behaviour of a 3D GIA model at a computational cost that is reduced by 3 to 5 orders of magnitude. It relies on LV-ELVA, a generalisation of (Bueler et al., 2007; Coulon et al., 2021), and on the Regional Sea-Level Model (ReSeLeM).","category":"page"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"FastIsostasy heavily relies on the Fast-Fourier Transform (FFT), as (1) its central PDE is solved by applying a Fourier collocation scheme and (2) important diagnostic fields are computed by matrix convolutions which can famously be accelerated by the use of FFT. FFT therefore inspired the name \"FastIsostasy\", along with a GitHub repository that eased the first steps of this package. The use of a performant language such as julia, as well as supporting performance-relevant computations on GPU allows FastIsostasy to live up to the expectations of low computation time.","category":"page"},{"location":"introGIA/","page":"Quick intro to GIA","title":"Quick intro to GIA","text":"We believe that FastIsostasy drastically reduces the burdens associated with using a 3D GIA model while offering all the complexity needed for ice-sheet modelling. As targeted and efficient climate-change mitigation relies on a good representation of important mechanisms in numerical models, we believe that this can be a significant contribution for future research.","category":"page"}]
}
